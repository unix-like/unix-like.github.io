<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Linux运维装逼指南</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.unix-like.com/"/>
  <updated>2017-05-29T14:05:31.845Z</updated>
  <id>http://www.unix-like.com/</id>
  
  <author>
    <name>Linux运维装逼指南</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows与Linux共享文件夹互相访问</title>
    <link href="http://www.unix-like.com/2017/05/29/service/%20Windows%E4%B8%8ELinux%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BA%92%E7%9B%B8%E8%AE%BF%E9%97%AE%20/"/>
    <id>http://www.unix-like.com/2017/05/29/service/ Windows与Linux共享文件夹互相访问 /</id>
    <published>2017-05-29T13:56:20.000Z</published>
    <updated>2017-05-29T14:05:31.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="首先安装并配置软件samba"><a href="#首先安装并配置软件samba" class="headerlink" title="首先安装并配置软件samba"></a>首先安装并配置软件samba</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">sudo yum install samba samba-client  </div><div class="line">vim /etc/samba/smb.conf  </div><div class="line">      </div><div class="line">找到security这行并将<span class="comment">#注释符号去掉改成  </span></div><div class="line">security = share     <span class="comment">#共享模式  </span></div><div class="line">      </div><div class="line">添加如下代码：  </div><div class="line">      </div><div class="line">[share]  </div><div class="line">comment = share  </div><div class="line">path = /home/<span class="built_in">test</span>          <span class="comment">#设置共享文件夹目录  </span></div><div class="line">browseable = yes  </div><div class="line">guest ok = yes  </div><div class="line">writable = yes  </div><div class="line"></div><div class="line">service smb start  </div><div class="line">service smbd start   (ubuntu)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="（1）在windows下访问Linux共享："><a href="#（1）在windows下访问Linux共享：" class="headerlink" title="（1）在windows下访问Linux共享："></a>（1）在windows下访问Linux共享：</h2><p>直接在windows运行里输入\192.168.16.128即可访问linux共享资源，并且不需要密码。</p>
<h2 id="（2）在linux下访问windows共享："><a href="#（2）在linux下访问windows共享：" class="headerlink" title="（2）在linux下访问windows共享："></a>（2）在linux下访问windows共享：</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">smbclient -L 192.168.16.1 -U xiaoxing   <span class="comment"># 查看共享了那些目录，由此知道主机名为XIAOXING-PC</span></div><div class="line"></div><div class="line">smbclient //192.168.16.1/Users -U xiaoxing     输入windows密码即可进入</div></pre></td></tr></table></figure>
<p>直接挂载windows共享目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo mount -t smbfs -o username=xiaoxing,password=123456   //XIAOXING-PC/system /mnt/win/</div><div class="line">或者：</div><div class="line">sudo mount -t smbfs -o username=xiaoxing,password=123456   //192.168.16.1/system /mnt/win/</div><div class="line">或者：</div><div class="line">sudo mount -t smbfs -o username=xiaoxing,password=123456,ip=192.168.16.1 //XIAOXING-PC/system /mnt/win/</div></pre></td></tr></table></figure>
<p>注意：</p>
<p>如果出现如下错误：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount: unknown filesystem <span class="built_in">type</span> ’smbfs’</div></pre></td></tr></table></figure>
<p>说明系统已经不能识别smbfs文件系统了，查资料说RHE5的kernel已经不再支持smbfs，而改用Common Internet File Systemcifs(cifs)取代了原有的smbfs，所以命令就改为:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mount -t cifs -o username=xiaoxing,password=123456   //192.168.16.1/system /mnt/win/</div></pre></td></tr></table></figure>
<p>解开挂载</p>
<p>断开刚才挂载在linux /mnt/win/路径上的winodws共享文件夹。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo umount /mnt/win/</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;首先安装并配置软件samba&quot;&gt;&lt;a href=&quot;#首先安装并配置软件samba&quot; class=&quot;headerlink&quot; title=&quot;首先安装并配置软件samba&quot;&gt;&lt;/a&gt;首先安装并配置软件samba&lt;/h1&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sudo yum install samba samba-client  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;vim /etc/samba/smb.conf  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;找到security这行并将&lt;span class=&quot;comment&quot;&gt;#注释符号去掉改成  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;security = share     &lt;span class=&quot;comment&quot;&gt;#共享模式  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;添加如下代码：  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[share]  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;comment = share  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;path = /home/&lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;          &lt;span class=&quot;comment&quot;&gt;#设置共享文件夹目录  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;browseable = yes  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;guest ok = yes  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;writable = yes  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;service smb start  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;service smbd start   (ubuntu)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="service" scheme="http://www.unix-like.com/categories/service/"/>
    
    
      <category term="samba" scheme="http://www.unix-like.com/tags/samba/"/>
    
  </entry>
  
  <entry>
    <title>系统运维工程师装逼完全指南</title>
    <link href="http://www.unix-like.com/2017/05/28/life/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%A3%85%E9%80%BC%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://www.unix-like.com/2017/05/28/life/系统运维工程师装逼完全指南/</id>
    <published>2017-05-28T10:49:44.000Z</published>
    <updated>2017-05-28T15:23:41.168Z</updated>
    
    <content type="html"><![CDATA[<p>1、全球化的认证有助于提升逼格，什么OCM、CCIE、RHCA、CISSP等等能考都考，再不济，也要有一张系统架构设计师或者网络规划设计师的信产部认证。每过一个认证，逼格提升一档。</p>
<a id="more"></a>
<p>2、TCP/IP协议、Linux内核深入研究、ORACLE大全等等之类的超过1千页大本头的书能有效提升B格，一定要放手边。不懂不要紧，别人能看见就行了。真有人跟你谈这些，也别担心装B失败，谈网络就从TCP的实现谈起，谈Linux就从内存的管理谈起，谈数据库就从各数据库SQL语句的源码实现谈起。如果有人跟你谈MS的东西也不要紧，就说自己之前有多年的微软的工作经历，外包的也算。反正也不会有查。有人非要跟你谈硬件，最次也要从计算机部件分类谈起吧。</p>
<p>3、大众化的东西要少用。能用ATS，就别用squid；能用postgresql，就别用MySQL；坚信什么nginx、lighty这种webserver要比apache好一万倍，而且apache能实现的功能，这些都能实现，不行就自己写模块、写扩展。实在要用apache，也别用高版本，抱死1.3的系统。有人要是问起，就说这是基于1.3的版是自己深度二次开发版本。实在要找不到的话也不要紧，没事在sf、oschina上看看什么下载量少的项目，背背项目简介啥的。不得不说，这两个网站太贴心，分类都给你做好了。总之，小众的东西能很有效的提升你的装逼级别。</p>
<p>4、写脚本的话，别用grep、sort 、uniq、管道这类命令。使用纯粹的awk、sed的实现，长度不要紧，阅读性、性能也不是问题。功能实现了，别人都还不懂这就是关键。如果真有人来请教，也要装出一副很简单的表情。切记不要摇头尾巴晃。就算是你是从《sed和awk》这种书上抄你自己也不一定能看懂的代码。</p>
<p>5、虽然会shell，但也要少用shell。初级装逼者，系统管理会首选perl、python、php这类3p的工具，而且要对shell这种语言有一种不屑。把什么性能、移植性、面向对象要常挂嘴边。如果还能再写几行什么erlang、ruby、lua这类语言做系统管理，绝对是装B神器，也是中级装逼的标准。高级装逼者会有Haskell这类函数式语言进行系统管理，这绝对是装B的B2轰炸机呀。当然，资深装逼者会返璞归真，使用面向对象进行shell编程。对，你没看错，是使用OO进行shell编程。</p>
<p>6、当谈到Redhat、ubuntu这类大众发行版本时，就回复一个字“切！”LFS、Gentoo这类系统绝对是装逼的首选。不为什么，就为在无穷尽的编译中找到属于自己的快感。如果非装大众发行版，也要从开机画面、登陆提示等等地方打自己上深刻的烙印。装逼的寂寞岂是一般人能懂的。</p>
<p>7、对什么checkpoint，juniper等表示不屑。必须天天把iptabes的链和表都挂在嘴边，尤其是mangle表。原则上对商用产品的一律不屑一顾，什么f5，radware一律自己开发实现。至于意外的将自己关在外面的事情一定要严格遵守各自公司的保密协议。</p>
<p>8、对于操作终端呢，像SecureCRT、xshell这种绝对是不用的，一定要用最原始的，什么黑屏绿字只是初级装逼者的水平，中高级则是Alpha半透明终端，桌面背景在设置个全球internet流量趋势图。让你根本就不知道他天天对着屏幕在敲什么东西。有事没事编译一些大型软件，看着翻滚的屏幕做思考状。</p>
<p>9、名片的title一定要是系统架构师，没有名片也不要紧，什么QQ签名、人人状态、微博简介上，有人看的地方一定要写上。这些都是提升B格的好地方。</p>
<p>10、初级装逼谈流量、PV、自动化；中级装逼谈流程、谈规范，什么ITIL、ITSM要常挂嘴边；高级装逼谈架构、谈模式；资深装逼则谈合同、谈成本。</p>
<p>11、混圈子对装逼来非常有必要的。什么XX沙龙、XX架构师大会、XX优化大会之类必要是常客，露个B脸就行。基本原则就是跟搞系统谈网络，跟搞网络的谈数据库，跟搞数据库的谈安全……对方不懂什么就谈什么对就了</p>
<p>12、最后，骨灰级早就超出三界外，不在五行中，他们注定有着传奇的色彩。他们正忙于对装逼者们进行职业发展规划。装逼助理、初级装逼、高级装逼、资深装逼、装逼总监直至CBO。如果发展了到了CBO，那么你一定是一位惊天地、泣鬼神的一代B神，一统江湖的教主，供万千iBer敬仰。darling，我很看好你哟！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、全球化的认证有助于提升逼格，什么OCM、CCIE、RHCA、CISSP等等能考都考，再不济，也要有一张系统架构设计师或者网络规划设计师的信产部认证。每过一个认证，逼格提升一档。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.unix-like.com/categories/life/"/>
    
    
      <category term="职业" scheme="http://www.unix-like.com/tags/%E8%81%8C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>运维人装逼指南大全</title>
    <link href="http://www.unix-like.com/2017/05/28/life/%E8%BF%90%E7%BB%B4%E4%BA%BA%E8%A3%85%E9%80%BC%E6%8C%87%E5%8D%97%E5%A4%A7%E5%85%A8/"/>
    <id>http://www.unix-like.com/2017/05/28/life/运维人装逼指南大全/</id>
    <published>2017-05-28T10:27:19.000Z</published>
    <updated>2017-05-28T10:48:50.244Z</updated>
    
    <content type="html"><![CDATA[<p>曾经有一首诗是这么写的</p>
<blockquote>
<p>装逼，是一种态度??</p>
<p>装逼的人生不可限量</p>
<p>装逼如煲汤</p>
<p>遇到烹制的高手，逼格立马飙升</p>
</blockquote>
<a id="more"></a>
<p>装逼，已被业界大神誉为当代职场人的基本素养</p>
<p>可是</p>
<p>网上流传的装逼指南一大把</p>
<p>唯独缺少咱运维人的这一发</p>
<p>今天线哥就帮大家来扒一扒</p>
<p>咱们一起把这装逼宝典传承下</p>
<p>　　话说，运维人拥有天然装逼优势，面对无数迭代升级的软硬件，数都数不过来的各类技术，互联网、云计算、大数据的热潮，跑断腿的各类行业大会……这些都为我们营造了极好的客观条件。</p>
<p>　　可以说，在全民都看你的时代，你不装逼，不仅浪费了你这一身好手段，而且辜负了天恩浩荡呀！</p>
<p>　　线哥虽是运营人，但长期浸淫在运维大咖身边，韬光养晦，苦练内功，总结了历来大神的装逼心得，并且通过实战检验，可谓天下无双，故取名曰《装逼宝典》，以补《葵花宝典》千年缺配。</p>
<p>　　现在很多运维人逼格不高，主要是因其来路不正，“小米+步枪”的时代远去，来路不正永远低人一等。所以一张权威的架构师认证就显得无比重要了，国内比较权威的系统架构设计师或者网络规划设计师的认证要考，国际的什么OCM、CCIE、RHCA、CISSP等等更要考，有了这些证件决定你在哪一个层次装逼，当然了，逼格的飙升也有赖于部分努力。</p>
<p>　　你会发现一些资深装逼手边永远摆着几本大部头的书，看着都瘆人。何谓大部头，什么？几百页的书你也好意思提，至少得上千页，才配称得上大部头。像什么TCP/IP协议、Linux内核研究、ORACLE大全等等。书一定要摆在显眼位置，你不用担心万一有人问起装逼遭遇滑铁卢。如果有人问硬件，你可以从计算机硬件基础谈起，有人问MS的内容，你那几年微软外包工作经历正好派上用场，现在数据库比较热，你可以从SQL语句的源码开聊，网络就谈TCP，Linux就谈内存管理。聊着聊着，你自己都被自己感动了，征服了。</p>
<h1 id="跟菜鸟划开界限"><a href="#跟菜鸟划开界限" class="headerlink" title="跟菜鸟划开界限"></a>跟菜鸟划开界限</h1><p>　　菜鸟在管理系统上经常选用perl、python、php这些3p工具，你要避开这些工具，另外shell也要少用，当菜鸟问起，你要表现出不屑来。如果做系统管理你要会写几行erlang、ruby、lua这类语言，如果你胆儿够大，可以整一整Haskell这类函数式语言。我敢说，懂一点这个，你绝对把逼装大了。</p>
<h1 id="避开大众化路线"><a href="#避开大众化路线" class="headerlink" title="避开大众化路线"></a>避开大众化路线</h1><p>　　当别人问你用squid吗？你说你用ATS；当别人问你用MySQL吗？你说你用postgresql；当别人为你用apache吗？你说你用nginx、lighty。如果你发现当别人也在学习这些技术了，你就到sf、oschina网站上看看那些下载量小的项目，多背背项目简介，当他们在你面前炫耀新技术时，你跟他们聊一聊这些项目，这时你发现他们只剩下长大了的嘴。你要记住，越小众的东西越显得高逼格，小众意味着高端，这是历史反复验证的。</p>
<h1 id="为自己代言"><a href="#为自己代言" class="headerlink" title="为自己代言"></a>为自己代言</h1><p>　　不装逼的人永远不懂装逼人的寂寞，装逼到极致是高冷的，曲高和寡。比如当大家还在谈Redhat、ubuntu这类大众发行版本时，你总是有意无意间避开，别人问你看法的时候，你对此不置一词，反而大谈特谈LFS、Gentoo。因为大众的东西是别人的，扒到属于自己的东西才显得更有张力，会带来不一样的快感呦。</p>
<p>　　很多人写脚本都爱用grep、sort 、uniq这类命令，这类命令的功能比较复杂，而你术业有专攻，使用最纯粹的awk、sed来实现，最关键的是当你用它们实现某些功能，别人都看不懂。别人不懂就会问，而这时你却表现出一副轻描淡写的表情。而这些对于他们来说，就算抄书也不一定真能看懂。</p>
<h1 id="设置屏幕放大招"><a href="#设置屏幕放大招" class="headerlink" title="设置屏幕放大招"></a>设置屏幕放大招</h1><p>　　操作终端一定要大肆显摆，那种黑屏绿字好莱坞大片式简直弱爆了，你用的是什么，是Alpha半透明终端，最好在桌面设置一个全球internet流量走势图，偶尔对着翻滚的屏幕做深入思考状，谁也不知道你在琢磨什么惊天地泣鬼神的东西。</p>
<h1 id="处处留情"><a href="#处处留情" class="headerlink" title="处处留情"></a>处处留情</h1><p>　　软硬件都解决了，这时候作为运维人的装逼基础已经够完美了，可是距离互联网大神级别还有距离。这时候你要抓住一切手段营销自己。不要让“网管”这个词在你耳朵边出现，你要时刻在明面暗面提示别人，我是架构师或规划师，把所有能展示自己title的地方都写上，什么名片啊、微信啊、QQ签名、脉脉、拉勾网等等，当然如果你愿意加上”首都在线“的前缀，可能效果会出奇不意。</p>
<h1 id="混精英圈子"><a href="#混精英圈子" class="headerlink" title="混精英圈子"></a>混精英圈子</h1><p>　　混圈子对于装逼是极为重要的。现在各种大会很多，鱼龙混杂，像什么GMIC、ChinaJoy之类的大会很难找到自己定位，而一般的XX架构师大会、XX优化大会、XX沙龙最多混个脸熟就好了。主要瞄准几个特定场合可获得四两拨千斤的效果，比如什么青年计算机学会论坛，统计之都论坛，以及蝴蝶沙龙，尤其蝴蝶沙龙是一个比较纯粹的架构师聚会，多去混这种场子，争取能演讲，那么你在这个圈子就很接近大神级人物了。</p>
<h1 id="精通云计算"><a href="#精通云计算" class="headerlink" title="精通云计算"></a>精通云计算</h1><p>　　一般而言，骨灰级的大神被当作信仰一样崇拜，这些人物大都具有传奇色彩，据线哥多年观察，这些人物的思考域比较广，他思考问题具有生态图谱效应，比如做架构师，你一定要多思考云计算，了解SAAS，熟悉PAAS，精通IAAS。尤其关注当前IAAS战略趋势以及差异化发展。当前的经济趋势是企业出海，不管是电商、游戏还是视频企业，都在向海外拓展业务，在倡导全球云计算布局领域中，国内首要关注首都在线，因为这是首家全球一体化云计算服务商，拥有全球私网GPN，通过它能够高效稳定安全连接世界。</p>
<p>　　最后不得不说，装逼是个系统工程，从装逼助理、装逼专员、高级装逼、资深装逼、装逼总监直至CBO。取经之路漫长，你在哪个层级不重要，重要的是，装逼精神不弃，奋斗之路不止。送给万千参透“人生如戏”的职场运维人士们！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;曾经有一首诗是这么写的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;装逼，是一种态度??&lt;/p&gt;
&lt;p&gt;装逼的人生不可限量&lt;/p&gt;
&lt;p&gt;装逼如煲汤&lt;/p&gt;
&lt;p&gt;遇到烹制的高手，逼格立马飙升&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.unix-like.com/categories/life/"/>
    
    
      <category term="职业" scheme="http://www.unix-like.com/tags/%E8%81%8C%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>tc命令——Linux基于IP进行流量限速</title>
    <link href="http://www.unix-like.com/2017/05/28/service/tc%E5%91%BD%E4%BB%A4Linux%E5%9F%BA%E4%BA%8EIP%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E9%99%90%E9%80%9F/"/>
    <id>http://www.unix-like.com/2017/05/28/service/tc命令Linux基于IP进行流量限速/</id>
    <published>2017-05-28T05:18:20.000Z</published>
    <updated>2017-05-28T05:28:24.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、TC原理"><a href="#一、TC原理" class="headerlink" title="一、TC原理"></a>一、TC原理</h1><p>　　Linux操作系统中的流量控制器TC（Traffic Control）用于Linux内核的流量控制，主要是通过在输出端口处建立一个队列来实现流量控制。</p>
<a id="more"></a>
<p>　　接收包从输入接口进来后，经过流量限制丢弃不符合规定的数据包，由输入多路分配器进行判断选择：</p>
<ul>
<li>如果接收包的目的主机是本主机，那么将该包送给上层处理，否则需要进行转发，将接收包交到转发块（Forwarding Block）处理。</li>
<li>转发块同时也接收本主机上层(TCP、UDP等)产生的包，通过查看路由表，决定所处理包的下一跳。</li>
<li>然后，对包进行排列以便将它们送到输出接口。</li>
</ul>
<p>　　一般只能限制网卡发送的数据包，不能限制网卡接收的数据包，所以可以通过改变发送次序靠控制传输速率。Linux流量控制主要是在输出接口排列时进行处理和实现的。</p>
<h1 id="二、TC规则"><a href="#二、TC规则" class="headerlink" title="二、TC规则"></a>二、TC规则</h1><h2 id="2-1、流量控制方式"><a href="#2-1、流量控制方式" class="headerlink" title="2.1、流量控制方式"></a>2.1、流量控制方式</h2><p>　　流量控制包括以下几种方式：</p>
<ul>
<li>SHAPING(限制) </li>
</ul>
<p>　　当流量被限制，它的传输速率就被控制在某个值以下。限制值可以大大小于有效带宽，这样可以平滑突发数据流量，使网络更为稳定。shaping（限制）只适用于向外的流量。</p>
<ul>
<li>SCHEDULING(调度)      </li>
</ul>
<p>　　通过调度数据包的传输，可以在带宽范围内，按照优先级分配带宽。SCHEDULING(调度)也只适于向外的流量。</p>
<ul>
<li>POLICING(策略)      </li>
</ul>
<p>　　SHAPING用于处理向外的流量，而POLICIING(策略)用于处理接收到的数据。</p>
<ul>
<li>DROPPING(丢弃)      </li>
</ul>
<p>　　如果流量超过某个设定的带宽，就丢弃数据包，不管是向内还是向外。</p>
<h2 id="2-2、流量控制处理对象"><a href="#2-2、流量控制处理对象" class="headerlink" title="2.2、流量控制处理对象"></a>2.2、流量控制处理对象</h2><p>　　流量的处理由三种对象控制，它们是：</p>
<ul>
<li>qdisc(排队规则)</li>
<li>class(类别)</li>
<li>filter(过滤器)</li>
</ul>
<h3 id="QDISC-排队规则"><a href="#QDISC-排队规则" class="headerlink" title="QDISC(排队规则)"></a>QDISC(排队规则)</h3><p>　　QDisc(排队规则)是queueing discipline的简写，它是理解流量控制(traffic control)的基础。<strong>无论何时，内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的qdisc(排队规则)把数据包加入队列。</strong> 然后，内核会尽可能多地从qdisc里面取出数据包，把它们交给网络适配器驱动模块。最简单的QDisc是pfifo它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。不过，它会保存网络接口一时无法处理的数据包。</p>
<p>　　QDISC的类别如下：</p>
<h4 id="（1）、CLASSLESS-QDisc-不可分类QDisc"><a href="#（1）、CLASSLESS-QDisc-不可分类QDisc" class="headerlink" title="（1）、CLASSLESS QDisc(不可分类QDisc)"></a>（1）、CLASSLESS QDisc(不可分类QDisc)</h4><h5 id="1-无类别QDISC包括："><a href="#1-无类别QDISC包括：" class="headerlink" title="1. 无类别QDISC包括："></a>1. 无类别QDISC包括：</h5><p>　　<strong>[p|b]fifo</strong></p>
<p>　　使用最简单的qdisc，纯粹的先进先出。只有一个参数：limit，用来设置队列的长度,pfifo是以数据包的个数为单位；bfifo是以字节数为单位。</p>
<p>　　<strong>pfifo_fast</strong></p>
<p>　　在编译内核时，如果打开了高级路由器(Advanced Router)编译选项，pfifo_fast就是系统的标准QDISC。它的队列包括三个波段(band)。在每个波段里面，使用先进先出规则。而三个波段(band)的优先级也不相同，band 0的优先级最高，band 2的最低。如果band里面有数据包，系统就不会处理band 1里面的数据包，band 1和band 2之间也是一样。数据包是按照服务类型(Type of Service,TOS)被分配多三个波段(band)里面的。</p>
<p>　　<strong>red</strong></p>
<p>　　red是Random Early Detection(随机早期探测)的简写。如果使用这种QDISC，当带宽的占用接近于规定的带宽时，系统会随机地丢弃一些数据包。它非常适合高带宽应用。</p>
<p>　　<strong>sfq</strong></p>
<p>　　sfq是Stochastic Fairness Queueing的简写。它按照会话(session–对应于每个TCP连接或者UDP流)为流量进行排序，然后循环发送每个会话的数据包。</p>
<p>　　<strong>tbf</strong></p>
<p>　　tbf是Token Bucket Filter的简写，适合于把流速降低到某个值。</p>
<h5 id="2-不可分类QDisc的配置"><a href="#2-不可分类QDisc的配置" class="headerlink" title="2. 不可分类QDisc的配置"></a>2. 不可分类QDisc的配置</h5><p>　　如果没有可分类QDisc，不可分类QDisc只能附属于设备的根。它们的用法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc add dev DEV root QDISC QDISC-PARAMETERS</div></pre></td></tr></table></figure>
<p>　　要删除一个不可分类QDisc，需要使用如下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc del dev DEV root</div></pre></td></tr></table></figure>
<p>　　一个网络接口上如果没有设置QDisc，pfifo_fast就作为缺省的QDisc。</p>
<h4 id="（2）、CLASSFUL-QDISC-分类QDisc"><a href="#（2）、CLASSFUL-QDISC-分类QDisc" class="headerlink" title="（2）、CLASSFUL QDISC(分类QDisc)"></a>（2）、CLASSFUL QDISC(分类QDisc)</h4><h5 id="可分类的QDisc包括："><a href="#可分类的QDisc包括：" class="headerlink" title="可分类的QDisc包括："></a>可分类的QDisc包括：</h5><p>　　<strong>CBQ</strong></p>
<p>　　CBQ是Class Based Queueing(基于类别排队)的缩写。它实现了一个丰富的连接共享类别结构，既有限制(shaping)带宽的能力，也具有带宽优先级管理的能力。带宽限制是通过计算连接的空闲时间完成的。空闲时间的计算标准是数据包离队事件的频率和下层连接(数据链路层)的带宽。</p>
<p>　　<strong>HTB</strong></p>
<p>　　HTB是Hierarchy Token Bucket的缩写。通过在实践基础上的改进，它实现了一个丰富的连接共享类别体系。使用HTB可以很容易地保证每个类别的带宽，虽然它也允许特定的类可以突破带宽上限，占用别的类的带宽。HTB可以通过TBF(Token Bucket Filter)实现带宽限制，也能够划分类别的优先级。</p>
<p>　　<strong>PRIO</strong></p>
<p>　　PRIO QDisc不能限制带宽，因为属于不同类别的数据包是顺序离队的。使用PRIO QDisc可以很容易对流量进行优先级管理，只有属于高优先级类别的数据包全部发送完毕，才会发送属于低优先级类别的数据包。为了方便管理，需要使用iptables或者ipchains处理数据包的服务类型(Type Of Service,ToS)。</p>
<h3 id="CLASS-类"><a href="#CLASS-类" class="headerlink" title="CLASS(类)"></a>CLASS(类)</h3><p>　　某些QDisc(排队规则)可以包含一些类别，不同的类别中可以包含更深入的QDisc(排队规则)，通过这些细分的QDisc还可以为进入的队列的数据包排队。通过设置各种类别数据包的离队次序，QDisc可以为设置网络数据流量的优先级。</p>
<h3 id="FILTER-过滤器"><a href="#FILTER-过滤器" class="headerlink" title="FILTER(过滤器)"></a>FILTER(过滤器)</h3><p>　　Filter(过滤器)用于为数据包分类，决定它们按照何种QDisc进入队列。无论何时数据包进入一个划分子类的类别中，都需要进行分类。分类的方法可以有多种，使用fileter(过滤器)就是其中之一。使用filter(过滤器)分类时，内核会调用附属于这个类(class)的所有过滤器，直到返回一个判决。如果没有判决返回，就作进一步的处理，而处理方式和QDISC有关。需要注意的是，filter(过滤器)是在QDisc内部，它们不能作为主体。</p>
<h2 id="2-3、操作原理"><a href="#2-3、操作原理" class="headerlink" title="2.3、操作原理"></a>2.3、操作原理</h2><p>　　类(Class)组成一个树，每个类都只有一个父类，而一个类可以有多个子类。某些QDisc(例如：CBQ和HTB)允许在运行时动态添加类，而其它的QDisc(例如：PRIO)不允许动态建立类。允许动态添加类的QDisc可以有零个或者多个子类，由它们为数据包排队。此外，每个类都有一个叶子QDisc，默认情况下，这个叶子QDisc使用pfifo的方式排队，我们也可以使用其它类型的QDisc代替这个默认的QDisc。而且，这个叶子叶子QDisc有可以分类，不过每个子类只能有一个叶子QDisc。 当一个数据包进入一个分类QDisc，它会被归入某个子类。</p>
<p>　　我们可以使用以下三种方式为数据包归类，不过不是所有的QDisc都能够使用这三种方式：</p>
<ul>
<li>tc过滤器(tc filter)</li>
</ul>
<p>　　如果过滤器附属于一个类，相关的指令就会对它们进行查询。过滤器能够匹配数据包头所有的域，也可以匹配由ipchains或者iptables做的标记。</p>
<ul>
<li>服务类型(Type of Service)</li>
</ul>
<p>　　某些QDisc有基于服务类型（Type of Service,ToS）的内置的规则为数据包分类。</p>
<ul>
<li>skb-&gt;priority</li>
</ul>
<p>　　用户空间的应用程序可以使用SO_PRIORITY选项在skb-&gt;priority域设置一个类的ID。</p>
<p>　　树的每个节点都可以有自己的过滤器，但是高层的过滤器也可以直接用于其子类。</p>
<p>　　如果数据包没有被成功归类，就会被排到这个类的叶子QDisc的队中。相关细节在各个QDisc的手册页中。</p>
<h2 id="2-4、命名规则"><a href="#2-4、命名规则" class="headerlink" title="2.4、命名规则"></a>2.4、命名规则</h2><p>　　所有的QDisc、类和过滤器都有ID。ID可以手工设置，也可以有内核自动分配。ID由一个主序列号和一个从序列号组成，两个数字用一个冒号分开。</p>
<p>　　<strong>QDISC</strong></p>
<p>　　一个QDisc会被分配一个主序列号，叫做句柄(handle)，然后把从序列号作为类的命名空间。句柄采用象10:一样的表达方式。习惯上，需要为有子类的QDisc显式地分配一个句柄。</p>
<p>　　<strong>类(CLASS)</strong></p>
<p>　　在同一个QDisc里面的类分享这个QDisc的主序列号，但是每个类都有自己的从序列号，叫做类识别符(classid)。类识别符只与父QDisc有关，和父类无关。类的命名习惯和QDisc的相同。</p>
<p>　　<strong>过滤器(FILTER)</strong></p>
<p>　　过滤器的ID有三部分，只有在对过滤器进行散列组织才会用到。详情请参考tc-filters手册页。</p>
<h2 id="2-5、单位"><a href="#2-5、单位" class="headerlink" title="2.5、单位"></a>2.5、单位</h2><p>　　tc命令的所有参数都可以使用浮点数，可能会涉及到以下计数单位。</p>
<table>
<thead>
<tr>
<th>带宽或者流速单位：</th>
</tr>
</thead>
<tbody>
<tr>
<td>kbps</td>
<td>千字节/秒</td>
</tr>
<tr>
<td>mbps</td>
<td>兆字节/秒</td>
</tr>
<tr>
<td>kbit</td>
<td>KBits/秒</td>
</tr>
<tr>
<td>mbit</td>
<td>MBits/秒</td>
</tr>
<tr>
<td>bps或者一个无单位数字</td>
<td>字节数/秒</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>数据的数量单位：</th>
</tr>
</thead>
<tbody>
<tr>
<td>kb或者k</td>
<td>千字节</td>
</tr>
<tr>
<td>mb或者m</td>
<td>兆字节</td>
</tr>
<tr>
<td>mbit</td>
<td>兆bit</td>
</tr>
<tr>
<td>kbit</td>
<td>千bit</td>
</tr>
<tr>
<td>b或者一个无单位数字</td>
<td>字节数</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>时间的计量单位：</th>
</tr>
</thead>
<tbody>
<tr>
<td>s、sec或者secs</td>
<td>秒</td>
</tr>
<tr>
<td>ms、msec或者msecs</td>
<td>分钟</td>
</tr>
<tr>
<td>us、usec、usecs或者一个无单位数字</td>
<td>微秒</td>
</tr>
</tbody>
</table>
<h1 id="三、TC命令"><a href="#三、TC命令" class="headerlink" title="三、TC命令"></a>三、TC命令</h1><p>　　tc可以使用以下命令对QDisc、类和过滤器进行操作：</p>
<ul>
<li>add</li>
</ul>
<p>　　在一个节点里加入一个QDisc、类或者过滤器。添加时，需要传递一个祖先作为参数，传递参数时既可以使用ID也可以直接传递设备的根。如果要建立一个QDisc或者过滤器，可以使用句柄(handle)来命名；如果要建立一个类，可以使用类识别符(classid)来命名。</p>
<ul>
<li>remove</li>
</ul>
<p>　　删除有某个句柄(handle)指定的QDisc，根QDisc(root)也可以删除。被删除QDisc上的所有子类以及附属于各个类的过滤器都会被自动删除。</p>
<ul>
<li>change</li>
</ul>
<p>　　以替代的方式修改某些条目。除了句柄(handle)和祖先不能修改以外，change命令的语法和add命令相同。换句话说，change命令不能一定节点的位置。</p>
<ul>
<li>replace</li>
</ul>
<p>　　对一个现有节点进行近于原子操作的删除/添加。如果节点不存在，这个命令就会建立节点。</p>
<ul>
<li>link</li>
</ul>
<p>　　只适用于DQisc，替代一个现有的节点。</p>
<h1 id="四、具体操作"><a href="#四、具体操作" class="headerlink" title="四、具体操作"></a>四、具体操作</h1><p>　　Linux流量控制主要分为建立队列、建立分类和建立过滤器三个方面。</p>
<h2 id="4-1、基本实现步骤为："><a href="#4-1、基本实现步骤为：" class="headerlink" title="4.1、基本实现步骤为："></a>4.1、基本实现步骤为：</h2><ul>
<li>（1） 针对网络物理设备（如以太网卡eth0）绑定一个队列QDisc；</li>
<li>（2） 在该队列上建立分类class；</li>
<li>（3） 为每一分类建立一个基于路由的过滤器filter；</li>
<li>（4） 最后与过滤器相配合，建立特定的路由表。</li>
</ul>
<h2 id="4-2、环境模拟实例"><a href="#4-2、环境模拟实例" class="headerlink" title="4.2、环境模拟实例:"></a>4.2、环境模拟实例:</h2><p>　　流量控制器上的以太网卡(eth0) 的IP地址为192.168.1.66，在其上建立一个CBQ队列。假设包的平均大小为1000字节，包间隔发送单元的大小为8字节，可接收冲突的发送最长包数目为20字节。</p>
<p>　　假如有三种类型的流量需要控制: </p>
<ol>
<li>是发往主机1的，其IP地址为192.168.1.24。其流量带宽控制在8Mbit，优先级为2；</li>
<li>是发往主机2的，其IP地址为192.168.1.30。其流量带宽控制在1Mbit，优先级为1；</li>
<li>是发往子网1的，其子网号为192.168.1.0，子网掩码为255.255.255.0。流量带宽控制在1Mbit，优先级为6。</li>
</ol>
<h3 id="1-建立队列"><a href="#1-建立队列" class="headerlink" title="1. 建立队列"></a>1. 建立队列</h3><p>　　一般情况下，针对一个网卡只需建立一个队列。</p>
<p>　　将一个cbq队列绑定到网络物理设备eth0上，其编号为1:0；网络物理设备eth0的实际带宽为10 Mbit，包的平均大小为1000字节；包间隔发送单元的大小为8字节，最小传输包大小为64字节。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc add dev eth0 root handle 1: cbq bandwidth 10Mbit avpkt 1000 cell 8 mpu 64</div></pre></td></tr></table></figure>
<h3 id="2-建立分类"><a href="#2-建立分类" class="headerlink" title="2. 建立分类"></a>2. 建立分类</h3><p>　　分类建立在队列之上。</p>
<p>　　一般情况下，针对一个队列需建立一个根分类，然后再在其上建立子分类。对于分类，按其分类的编号顺序起作用，编号小的优先；一旦符合某个分类匹配规则，通过该分类发送数据包，则其后的分类不再起作用。</p>
<p>　　<strong>1） 创建根分类1:1；分配带宽为10Mbit，优先级别为8。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc class add dev eth0 parent 1:0 classid 1:1 cbq bandwidth 10Mbit rate 10Mbit maxburst 20 allot 1514 prio 8 avpkt 1000 cell 8 weight 1Mbit</div></pre></td></tr></table></figure>
<p>　　该队列的最大可用带宽为10Mbit，实际分配的带宽为10Mbit，可接收冲突的发送最长包数目为20字节；最大传输单元加MAC头的大小为1514字节，优先级别为8，包的平均大小为1000字节，包间隔发送单元的大小为8字节，相应于实际带宽的加权速率为1Mbit。</p>
<p>　　<strong>2）创建分类1:2，其父分类为1:1，分配带宽为8Mbit，优先级别为2。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc class add dev eth0 parent 1:1 classid 1:2 cbq bandwidth 10Mbit rate 8Mbit maxburst 20 allot 1514 prio 2 avpkt 1000 cell 8 weight 800Kbit split 1:0 bounded</div></pre></td></tr></table></figure>
<p>　　该队列的最大可用带宽为10Mbit，实际分配的带宽为 8Mbit，可接收冲突的发送最长包数目为20字节；最大传输单元加MAC头的大小为1514字节，优先级别为1，包的平均大小为1000字节，包间隔发送单元的大小为8字节，相应于实际带宽的加权速率为800Kbit，分类的分离点为1:0，且不可借用未使用带宽。</p>
<p>　　<strong>3）创建分类1:3，其父分类为1:1，分配带宽为1Mbit，优先级别为1。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc class add dev eth0 parent 1:1 classid 1:3 cbq bandwidth 10Mbit rate 1Mbit maxburst 20 allot 1514 prio 1 avpkt 1000 cell 8 weight 100Kbit split 1:0</div></pre></td></tr></table></figure>
<p>　　该队列的最大可用带宽为10Mbit，实际分配的带宽为 1Mbit，可接收冲突的发送最长包数目为20字节；最大传输单元加MAC头的大小为1514字节，优先级别为2，包的平均大小为1000字节，包间隔发送单元的大小为8字节，相应于实际带宽的加权速率为100Kbit，分类的分离点为1:0。</p>
<p>　　<strong>4）创建分类1:4，其父分类为1:1，分配带宽为1Mbit，优先级别为6。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc class add dev eth0 parent 1:1 classid 1:4 cbq bandwidth 10Mbit rate 1Mbit maxburst 20 allot 1514 prio 6 avpkt 1000 cell 8 weight 100Kbit split 1:0</div></pre></td></tr></table></figure>
<p>　　该队列的最大可用带宽为10Mbit，实际分配的带宽为1Mbit，可接收冲突的发送最长包数目为20字节；最大传输单元加MAC头的大小为1514字节，优先级别为6，包的平均大小为1000字节，包间隔发送单元的大小为8字节，相应于实际带宽的加权速率为100Kbit，分类的分离点为1:0。</p>
<h2 id="4-3-建立过滤器"><a href="#4-3-建立过滤器" class="headerlink" title="4.3. 建立过滤器"></a>4.3. 建立过滤器</h2><p>　　过滤器主要服务于分类。</p>
<p>一般只需针对根分类提供一个过滤器，然后为每个子分类提供路由映射。</p>
<p><strong>1） 应用路由分类器到cbq队列的根，父分类编号为1:0；过滤协议为ip，优先级别为100，过滤器为基于路由表。</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc filter add dev eth0 parent 1:0 protocol ip prio 100 route</div></pre></td></tr></table></figure>
<p><strong>2） 建立路由映射分类1:2, 1:3, 1:4</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tc filter add dev eth0 parent 1:0 protocol ip prio 100 route to 2 flowid 1:2</div><div class="line"></div><div class="line">tc filter add dev eth0 parent 1:0 protocol ip prio 100 route to 3 flowid 1:3</div><div class="line"></div><div class="line">tc filter add dev eth0 parent 1:0 protocol ip prio 100 route to 4 flowid 1:4</div></pre></td></tr></table></figure>
<h2 id="4-4-建立路由"><a href="#4-4-建立路由" class="headerlink" title="4.4.建立路由"></a>4.4.建立路由</h2><p>　　该路由是与前面所建立的路由映射一一对应。</p>
<p>　　<strong>1） 发往主机192.168.1.24的数据包通过分类2转发(分类2的速率8Mbit)</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip route add 192.168.1.24 dev eth0 via 192.168.1.66 realm 2</div></pre></td></tr></table></figure>
<p>　　<strong>2） 发往主机192.168.1.30的数据包通过分类3转发(分类3的速率1Mbit)</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip route add 192.168.1.30 dev eth0 via 192.168.1.66 realm 3</div></pre></td></tr></table></figure>
<p>　　<strong>3）发往子网192.168.1.0/24的数据包通过分类4转发(分类4的速率1Mbit)</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip route add 192.168.1.0/24 dev eth0 via 192.168.1.66 realm 4</div></pre></td></tr></table></figure>
<p>　　<strong>注</strong>：一般对于流量控制器所直接连接的网段建议使用IP主机地址流量控制限制，不要使用子网流量控制限制。如一定需要对直连子网使用子网流量控制限制，则在建立该子网的路由映射前，需将原先由系统建立的路由删除，才可完成相应步骤。</p>
<h2 id="4-5-监视"><a href="#4-5-监视" class="headerlink" title="4.5. 监视"></a>4.5. 监视</h2><p>　　主要包括对现有队列、分类、过滤器和路由的状况进行监视。</p>
<p>　　<strong>1）显示队列的状况</strong></p>
<p>　　简单显示指定设备(这里为eth0)的队列状况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tc qdisc ls dev eth0</div><div class="line"></div><div class="line">qdisc cbq 1: rate 10Mbit (bounded,isolated) prio no-transmit</div></pre></td></tr></table></figure>
<p>　　详细显示指定设备(这里为eth0)的队列状况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc -s qdisc ls dev eth0</div></pre></td></tr></table></figure>
<p>　　这里主要显示了通过该队列发送了13232个数据包，数据流量为7646731个字节，丢弃的包数目为0，超过速率限制的包数目为0。</p>
<p>　　<strong>2）显示分类的状况</strong></p>
<p>　　简单显示指定设备(这里为eth0)的分类状况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc class ls dev eth0</div></pre></td></tr></table></figure>
<p>　　详细显示指定设备(这里为eth0)的分类状况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc -s class ls dev eth0</div></pre></td></tr></table></figure>
<p>　　这里主要显示了通过不同分类发送的数据包，数据流量，丢弃的包数目，超过速率限制的包数目等等。其中根分类(class cbq 1:0)的状况应与队列的状况类似。</p>
<p>　　例如，分类class cbq 1:4发送了8076个数据包，数据流量为5552879个字节，丢弃的包数目为0，超过速率限制的包数目为0。</p>
<p>　　<strong>3）显示过滤器的状况</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc -s filter ls dev eth0</div></pre></td></tr></table></figure>
<p>　　这里flowid 1:2代表分类class cbq 1:2，to 2代表通过路由2发送。</p>
<p>　　<strong>4）显示现有路由的状况</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip route</div></pre></td></tr></table></figure>
<p>　　如上所示，结尾包含有realm的显示行是起作用的路由过滤器。</p>
<h1 id="五、实例脚本"><a href="#五、实例脚本" class="headerlink" title="五、实例脚本"></a>五、实例脚本</h1><h2 id="5-1-tc限速"><a href="#5-1-tc限速" class="headerlink" title="5.1 tc限速"></a>5.1 tc限速</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /bin/sh</span></div><div class="line"></div><div class="line">touch  /var/lock/subsys/<span class="built_in">local</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span>  1  &gt; /proc/sys/net/ipv4/ip_forward （激活转发）</div><div class="line"></div><div class="line">route add default  gw  10.0.0.0  (这是加入电信网关，如果你已设了不用这条）</div><div class="line"></div><div class="line">DOWNLOAD=640Kbit        (640/8 =80K ,我这里限制下载最高速度只能80K）</div><div class="line">UPLOAD=640Kbit          (640/8 =80K,上传速度也限制在80K）</div><div class="line">INET=192.168.0.         (设置网段，根据你的情况填）</div><div class="line">IPS=1                   (这个意思是从192.168.0.1开始）</div><div class="line">IPE=200                 (我这设置是从IP为192.168.0.1-200这个网段限速，根据自已的需要改）</div><div class="line">ServerIP=253            (网关IP）</div><div class="line">IDEV=eth0</div><div class="line">ODEV=eth1</div><div class="line"></div><div class="line">/sbin/tc  qdisc  del  dev  <span class="variable">$IDEV</span> root handle 10:</div><div class="line">/sbin/tc  qdisc  del  dev  <span class="variable">$ODEV</span>  root handle  20:</div><div class="line">/sbin/tc  qdisc  add  dev <span class="variable">$IDEV</span>  root  handle  10: cbq  bandwidth  100Mbit avpkt  1000</div><div class="line">/sbin/tc  qdisc  add  dev  <span class="variable">$ODEV</span>  root  handle  20: cbq bandwidth  1Mbit  avpkt  1000</div><div class="line">/sbin/tc  class  add  dev <span class="variable">$IDEV</span>  parent 10:0  classid  10:1  cbq  bandwidth  100Mbit  rate 100Mbit  allot 1514  weight  1Mbit  prio  8  maxburst  20  avpkt  1000</div><div class="line">/sbin/tc  class  add  dev  <span class="variable">$ODEV</span>  parent  20:0  classid  20:1 cbq  bandwidth  1Mbit  rate  1Mbit  allot  1514  weitht  10Kbit  prio  8  maxburst  20  avpkt  1000</div><div class="line"></div><div class="line">COUNTER=<span class="variable">$IPS</span></div><div class="line"><span class="keyword">while</span>  [  <span class="variable">$COUNTER</span>  -le  <span class="variable">$IPE</span>  ]</div><div class="line">    <span class="keyword">do</span></div><div class="line">/sbin/tc  class  add  dev  <span class="variable">$IDEV</span>  parent  10:1  classid  10:1<span class="variable">$COUNTER</span>  cbq  banwidth  100Mbit  rate  </div><div class="line"><span class="variable">$DOWNLOAD</span>  allot  1514  weight  20Kbit  prio  5  maxburst  20  avpkt  1000  bounded</div><div class="line">/sbin/tc  qdisc  add  dev  <span class="variable">$IDEV</span>  parent  10:1<span class="variable">$COUNTER</span>  sfq  quantum  1514b  perturb15</div><div class="line"></div><div class="line">/sbin/tc  filter  add  dev  <span class="variable">$IDEV</span>  parent  10:0  protocol  ip  prio  100  u32  match  ipdst  <span class="variable">$INET</span><span class="variable">$COUNTER</span>  flowid  10:1<span class="variable">$COUNTER</span></div><div class="line">      COUNTER=` expr  <span class="variable">$COUNTER</span>  +  1  `</div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line">iptables  -t  nat  -A  POSTROUTING  -o  eth1  <span class="_">-s</span>  192.168.0.0/24  -J  MASQUERADE</div></pre></td></tr></table></figure>
<h2 id="5-2-模型"><a href="#5-2-模型" class="headerlink" title="5.2 模型"></a>5.2 模型</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line">tc qdisc del dev eth7 root &amp;&gt; /dev/null</div><div class="line">tc qdisc del dev eth8 root &amp;&gt; /dev/null</div><div class="line"></div><div class="line"><span class="comment">#Add qdisc</span></div><div class="line">tc qdisc add dev eth7 root handle 10: htb default 9998</div><div class="line">tc qdisc add dev eth8 root handle 10: htb default 9998</div><div class="line"></div><div class="line"><span class="comment">#Add htb root node</span></div><div class="line">tc class add dev eth7 parent 10: classid 10:9999 htb rate 1000000kbit ceil 1000000kbit</div><div class="line">tc class add dev eth8 parent 10: classid 10:9999 htb rate 1000000kbit ceil 1000000kbit</div><div class="line"></div><div class="line"><span class="comment">#Add htb fake default node here</span></div><div class="line">tc class add dev eth7 parent 10:9999 classid 10:9998 htb rate 1000000kbit ceil 1000000kbit</div><div class="line">tc class add dev eth8 parent 10:9999 classid 10:9998 htb rate 1000000kbit ceil 1000000kbit</div><div class="line"></div><div class="line"><span class="comment">#Add rule node</span></div><div class="line">tc class add dev eth7 parent 10:9999 classid 10:3 htb rate 1kbit ceil 50kbit</div><div class="line">tc filter add dev eth7 parent 10: protocol ip handle 3 fw classid 10:3</div><div class="line">tc class add dev eth8 parent 10:9999 classid 10:3 htb rate 1kbit ceil 50kbit</div><div class="line">tc filter add dev eth8 parent 10: protocol ip handle 3 fw classid 10:3</div><div class="line"></div><div class="line"><span class="comment">#Add htb real default node here</span></div><div class="line">tc class change dev eth7 classid 10:9998 htb rate 1kbit ceil 1000000kbit</div><div class="line">tc class change dev eth8 classid 10:9998 htb rate 1kbit ceil 1000000kbit</div></pre></td></tr></table></figure>
<h2 id="5-3-限制一个IP上传下载速度"><a href="#5-3-限制一个IP上传下载速度" class="headerlink" title="5.3 限制一个IP上传下载速度"></a>5.3 限制一个IP上传下载速度</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#  tc uses the following units when passed as a parameter.</span></div><div class="line"><span class="comment">#  kbps: Kilobytes per second</span></div><div class="line"><span class="comment">#  mbps: Megabytes per second</span></div><div class="line"><span class="comment">#  kbit: Kilobits per second</span></div><div class="line"><span class="comment">#  mbit: Megabits per second</span></div><div class="line"><span class="comment">#  bps: Bytes per second</span></div><div class="line"><span class="comment">#       Amounts of data can be specified in:</span></div><div class="line"><span class="comment">#       kb or k: Kilobytes</span></div><div class="line"><span class="comment">#       mb or m: Megabytes</span></div><div class="line"><span class="comment">#       mbit: Megabits</span></div><div class="line"><span class="comment">#       kbit: Kilobits</span></div><div class="line"><span class="comment">#  To get the byte figure from bits, divide the number by 8 bit</span></div><div class="line"><span class="comment">#</span></div><div class="line"></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Name of the traffic control command.</span></div><div class="line">TC=/sbin/tc</div><div class="line"></div><div class="line"><span class="comment"># The network interface we're planning on limiting bandwidth.</span></div><div class="line">IF=em1             <span class="comment"># Interface</span></div><div class="line"></div><div class="line"><span class="comment"># Download limit (in mega bits)</span></div><div class="line">DNLD=80mbit          <span class="comment"># DOWNLOAD Limit</span></div><div class="line"></div><div class="line"><span class="comment"># Upload limit (in mega bits)</span></div><div class="line">UPLD=80mbit          <span class="comment"># UPLOAD Limit</span></div><div class="line"></div><div class="line"><span class="comment"># IP address of the machine we are controlling</span></div><div class="line">IP=125.64.15.21     <span class="comment"># Host IP</span></div><div class="line"></div><div class="line"><span class="comment"># Filter options for limiting the intended interface.</span></div><div class="line">U32=<span class="string">"<span class="variable">$TC</span> filter add dev <span class="variable">$IF</span> protocol ip parent 1:0 prio 1 u32"</span></div><div class="line"></div><div class="line"><span class="function"><span class="title">start</span></span>() &#123;</div><div class="line"></div><div class="line"><span class="comment"># We'll use Hierarchical Token Bucket (HTB) to shape bandwidth.</span></div><div class="line"><span class="comment"># For detailed configuration options, please consult Linux man</span></div><div class="line"><span class="comment"># page.</span></div><div class="line"></div><div class="line">    <span class="variable">$TC</span> qdisc add dev <span class="variable">$IF</span> root handle 1: htb default 30</div><div class="line">    <span class="variable">$TC</span> class add dev <span class="variable">$IF</span> parent 1: classid 1:1 htb rate <span class="variable">$DNLD</span></div><div class="line">    <span class="variable">$TC</span> class add dev <span class="variable">$IF</span> parent 1: classid 1:2 htb rate <span class="variable">$UPLD</span></div><div class="line">    <span class="variable">$U32</span> match ip dst <span class="variable">$IP</span>/32 flowid 1:1</div><div class="line">    <span class="variable">$U32</span> match ip src <span class="variable">$IP</span>/32 flowid 1:2</div><div class="line"></div><div class="line"><span class="comment"># The first line creates the root qdisc, and the next two lines</span></div><div class="line"><span class="comment"># create two child qdisc that are to be used to shape download</span></div><div class="line"><span class="comment"># and upload bandwidth.</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># The 4th and 5th line creates the filter to match the interface.</span></div><div class="line"><span class="comment"># The 'dst' IP address is used to limit download speed, and the</span></div><div class="line"><span class="comment"># 'src' IP address is used to limit upload speed.</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">stop</span></span>() &#123;</div><div class="line"></div><div class="line"><span class="comment"># Stop the bandwidth shaping.</span></div><div class="line">    <span class="variable">$TC</span> qdisc del dev <span class="variable">$IF</span> root</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">restart</span></span>() &#123;</div><div class="line"></div><div class="line"><span class="comment"># Self-explanatory.</span></div><div class="line">    stop</div><div class="line">    sleep 1</div><div class="line">    start</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="title">show</span></span>() &#123;</div><div class="line"></div><div class="line"><span class="comment"># Display status of traffic control status.</span></div><div class="line">    <span class="variable">$TC</span> <span class="_">-s</span> qdisc ls dev <span class="variable">$IF</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></div><div class="line"></div><div class="line">  start)</div><div class="line"></div><div class="line">    <span class="built_in">echo</span> -n <span class="string">"Starting bandwidth shaping: "</span></div><div class="line">    start</div><div class="line">    <span class="built_in">echo</span> <span class="string">"done"</span></div><div class="line">    ;;</div><div class="line"></div><div class="line">  stop)</div><div class="line"></div><div class="line">    <span class="built_in">echo</span> -n <span class="string">"Stopping bandwidth shaping: "</span></div><div class="line">    stop</div><div class="line">    <span class="built_in">echo</span> <span class="string">"done"</span></div><div class="line">    ;;</div><div class="line"></div><div class="line">  restart)</div><div class="line"></div><div class="line">    <span class="built_in">echo</span> -n <span class="string">"Restarting bandwidth shaping: "</span></div><div class="line">    restart</div><div class="line">    <span class="built_in">echo</span> <span class="string">"done"</span></div><div class="line">    ;;</div><div class="line"></div><div class="line">  show)</div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">"Bandwidth shaping status for <span class="variable">$IF</span>:"</span></div><div class="line">    show</div><div class="line">    <span class="built_in">echo</span> <span class="string">""</span></div><div class="line">    ;;</div><div class="line"></div><div class="line">  *)</div><div class="line"></div><div class="line">    <span class="built_in">pwd</span>=$(<span class="built_in">pwd</span>)</div><div class="line">    <span class="built_in">echo</span> <span class="string">"Usage: tc.bash &#123;start|stop|restart|show&#125;"</span></div><div class="line">    ;;</div><div class="line"></div><div class="line"><span class="keyword">esac</span></div><div class="line"></div><div class="line"><span class="built_in">exit</span> 0</div></pre></td></tr></table></figure>
<p>本文原文出处:<a href="http://leslie-chu.blog.163.com/blog/static/19986324320125414618221" target="_blank" rel="external">http://leslie-chu.blog.163.com/blog/static/19986324320125414618221</a></p>
<p>主要参考（所有权利归原文作者所有）：</p>
<p><a href="http://www.cnblogs.com/endsock/archive/2011/12/09/2281519.html" target="_blank" rel="external">http://www.cnblogs.com/endsock/archive/2011/12/09/2281519.html</a></p>
<p><a href="http://blog.163.com/ninja_wk/blog/static/989155620084280154811/" target="_blank" rel="external">http://blog.163.com/ninja_wk/blog/static/989155620084280154811/</a></p>
<p><a href="http://www.chinaunix.net/jh/4/16110.html" target="_blank" rel="external">http://www.chinaunix.net/jh/4/16110.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、TC原理&quot;&gt;&lt;a href=&quot;#一、TC原理&quot; class=&quot;headerlink&quot; title=&quot;一、TC原理&quot;&gt;&lt;/a&gt;一、TC原理&lt;/h1&gt;&lt;p&gt;　　Linux操作系统中的流量控制器TC（Traffic Control）用于Linux内核的流量控制，主要是通过在输出端口处建立一个队列来实现流量控制。&lt;/p&gt;
    
    </summary>
    
      <category term="service" scheme="http://www.unix-like.com/categories/service/"/>
    
    
      <category term="tc" scheme="http://www.unix-like.com/tags/tc/"/>
    
  </entry>
  
  <entry>
    <title>Linux上ssd优化</title>
    <link href="http://www.unix-like.com/2017/05/27/system/Linux%E4%B8%8Assd%E4%BC%98%E5%8C%96/"/>
    <id>http://www.unix-like.com/2017/05/27/system/Linux上ssd优化/</id>
    <published>2017-05-27T15:18:28.000Z</published>
    <updated>2017-05-27T15:19:32.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、修改默认的固态硬盘-SSD-柱面大小"><a href="#一、修改默认的固态硬盘-SSD-柱面大小" class="headerlink" title="一、修改默认的固态硬盘(SSD)柱面大小"></a>一、修改默认的固态硬盘(SSD)柱面大小</h1><p>　　提升Linux下固态硬盘的使用率，在安装Linux操作系统前就应该做相关工作。系统会先在磁盘上创建分区，通常创建的分区包含固定数量的柱面，而默认情况下，每个柱面由16065512个字节的扇区组成。</p>
<a id="more"></a>
<p>　　现在的问题是，当默认柱面空间大小被完全使用后，固态硬盘就不能发挥最佳性能。因为要固态硬盘读这个操作需要使用4KB的字节块，而固态硬盘控制器删除操 作则需要512KB的字节块。问题是，有了通常用于Linux上的默认分区，分区的开始没必要也是一个4KB新分区的开始。结果，一次读取或写入操作也许 需要SSD设备上的两个不同的区块，这也减缓了SSD磁盘的性能。</p>
<p>　　为了避免这种问题，可以采用fdisk方式来创建分区，配置三个选项来指定使用柱面及拍面大小。具体的命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fdisk -H 32 -C 32 –c /dev/sdb</div></pre></td></tr></table></figure>
<h1 id="二、配置固态硬盘-SSD-的文件系统"><a href="#二、配置固态硬盘-SSD-的文件系统" class="headerlink" title="二、配置固态硬盘(SSD)的文件系统"></a>二、配置固态硬盘(SSD)的文件系统</h1><h3 id="1-创建文件系统"><a href="#1-创建文件系统" class="headerlink" title="1.创建文件系统"></a>1.创建文件系统</h3><p>　　接着需要关注的就是文件系统。想要优化文件系统删除字节区块的效率，就必须确保小于512K的文件分布在不同的删除字节区块上。要做到这一点，必须确保在创建可扩展文件系统时指定了需要使用的条带的宽度和幅度。这些值在页面中指定，默认大小为4KB。要创建一个最佳的可扩展文件系统，应该使用如下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkfs.ext4 -E stride=128,stripe-width=128 /dev/sda1</div></pre></td></tr></table></figure>
<p>　　如果要修改现有的文件系统的参数，可以使用tune2fs实用程序：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tune2fs -E stride=128,stripe-width=128 /dev/sda1</div></pre></td></tr></table></figure>
<h3 id="2-文件系统日志"><a href="#2-文件系统日志" class="headerlink" title="2.文件系统日志"></a>2.文件系统日志</h3><p>　　关闭日志功能，可以延长SSD寿命，但是突然断电容易造成文件损坏</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tune2fs -O ^has_journal /dev/sda2  关闭日志；</div></pre></td></tr></table></figure>
<p>　　然后执行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e2fsck <span class="_">-f</span> /dev/sda2；</div></pre></td></tr></table></figure>
<p>　　检查日志是否关闭成功：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dmesg | grep EXT4</div></pre></td></tr></table></figure>
<p>　　如果显示 “EXT4-fs (sda2): mounted filesystem without journal”  说明关闭日志成功；否则显示 “mounted filesystem with ordered data mode”</p>
<p>　　要打开日志</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tune2fs -O has_journal /dev/sda2</div></pre></td></tr></table></figure>
<h3 id="3-设置noatime"><a href="#3-设置noatime" class="headerlink" title="3.设置noatime"></a>3.设置noatime</h3><p>　　不记录文件访问时间，该选项保证了文件的访问时间不会因为每次读取而更新，从而降低对文件系统的写入次数。</p>
<p>　　在fstb 中加入noatime　选项</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/dev/sda1 / ext4 discard,defaults  改为  /dev/sda1 / ext4 noatime,defaults</div></pre></td></tr></table></figure>
<h1 id="三、配置固态硬盘-SSD-的I-O调度程序"><a href="#三、配置固态硬盘-SSD-的I-O调度程序" class="headerlink" title="三、配置固态硬盘(SSD)的I/O调度程序"></a>三、配置固态硬盘(SSD)的I/O调度程序</h1><p>　　优化的第三个部分涉及到I/O调度程序。该模块是一个决定如何处理I/O请求的核心组件。默认情况下就是非常公平的排队，对于普通的磁盘驱动器来说，这是很好的方案，但对于以期限调度为优势的固态硬盘来说，这并不是最好的。</p>
<p>　　如果你想在系统中对所有磁盘采用期限调度，可以在内核加载时把<code>elevator=deadline</code>这句话加入到系统引导管理器(GURB)中;如果你只是想针对某一个磁盘，就应该在rc.local文件中加入类似如下实例的一句话，那么每次当系统重启，期限调度就会应用到指定的磁盘。如下实例将会对 /dev/sdb磁盘采用期限调度。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> deadline &gt; /sys/block/xvda/queue/scheduler</div></pre></td></tr></table></figure>
<p>　　给IO的算法修改成 noop,操作系统本身不做处理,让 ssd 本身处理.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> noop &gt;  /sys/block/sda/queue/scheduler</div></pre></td></tr></table></figure>
<h1 id="四、清理固态硬盘-SSD-中的数据块"><a href="#四、清理固态硬盘-SSD-中的数据块" class="headerlink" title="四、清理固态硬盘(SSD)中的数据块"></a>四、清理固态硬盘(SSD)中的数据块</h1><p>　　最后一个重要的步骤称为“清理”，该操作可以确保在删除文件后相应的数据块真正清空，然后在创建新的文件时才能有可用的数据块。如果没有清理操作，一旦数 据块空间填满，固态硬盘的性能就会下降。如果使用丢弃挂载选项，当文件删除后，数据块也会被相应地清除，这样可以显著提高固态硬盘的性能。2.6.33以 上的内核已经支持清理操作。</p>
<p>　　Linux内核从2.6.33开始提供TRIM支持，所以先运行“uname -a”命令，查看自己的内核版本，如果内核版本低于2.6.33的，请先升级内核。然后运行“hdparm -I /dev/sda”查看自己的硬盘支不支持TRIM技术，如果支持，你会看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* Data Set Management TRIM supported</div></pre></td></tr></table></figure>
<p>　　注意：如果SSD组RAID0后，将失去Trim功能</p>
<p>　　如果上面两个条件都满足了，就可以在fstab中添加discard来开启TRIM功能，如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">原始的UUID=2f6be0cf-2f54-4646-b8c6-5fb0aa01ef23 / ext4 defaults,errors=remount-ro 0 1</div><div class="line">改后的UUID=2f6be0cf-2f54-4646-b8c6-5fb0aa01ef23 / ext4 discard,defaults,errors=remount-ro,noatime 0 1</div></pre></td></tr></table></figure>
<p>　　在fasab配置文件中完成对文件系统的这些修改后，重启计算机，或者通知文件系统重新读取其配置，然后使用/etc/fstab文件中包含的mount -o remount命令重新安装每个文件系统。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、修改默认的固态硬盘-SSD-柱面大小&quot;&gt;&lt;a href=&quot;#一、修改默认的固态硬盘-SSD-柱面大小&quot; class=&quot;headerlink&quot; title=&quot;一、修改默认的固态硬盘(SSD)柱面大小&quot;&gt;&lt;/a&gt;一、修改默认的固态硬盘(SSD)柱面大小&lt;/h1&gt;&lt;p&gt;　　提升Linux下固态硬盘的使用率，在安装Linux操作系统前就应该做相关工作。系统会先在磁盘上创建分区，通常创建的分区包含固定数量的柱面，而默认情况下，每个柱面由16065512个字节的扇区组成。&lt;/p&gt;
    
    </summary>
    
      <category term="system" scheme="http://www.unix-like.com/categories/system/"/>
    
    
      <category term="调优" scheme="http://www.unix-like.com/tags/%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>rsync安装配置实例</title>
    <link href="http://www.unix-like.com/2017/05/26/service/rsync%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B/"/>
    <id>http://www.unix-like.com/2017/05/26/service/rsync安装配置实例/</id>
    <published>2017-05-26T02:48:58.000Z</published>
    <updated>2017-05-26T02:59:01.565Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细介绍了rsync安装配置实例。<br><a id="more"></a></p>
<h1 id="一-安装rsync"><a href="#一-安装rsync" class="headerlink" title="一. 安装rsync"></a>一. 安装rsync</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install rsync</div></pre></td></tr></table></figure>
<h1 id="二-配置rsync服务器端"><a href="#二-配置rsync服务器端" class="headerlink" title="二. 配置rsync服务器端"></a>二. 配置rsync服务器端</h1><h3 id="1、-修改rsync的配置文件"><a href="#1、-修改rsync的配置文件" class="headerlink" title="1、  修改rsync的配置文件"></a>1、  修改rsync的配置文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">cat /etc/xinetd.d/rsync</div><div class="line"></div><div class="line"><span class="comment"># default: off</span></div><div class="line"><span class="comment"># description: The rsync server is a good addition to an ftp server, as it \</span></div><div class="line"><span class="comment">#   allows crc checksumming etc.</span></div><div class="line">service rsync</div><div class="line">&#123;</div><div class="line">    <span class="built_in">disable</span> = yes</div><div class="line">    flags           = IPv6</div><div class="line">    socket_type     = stream</div><div class="line">    <span class="built_in">wait</span>            = no</div><div class="line">    user            = root</div><div class="line">    server          = /usr/bin/rsync</div><div class="line">    server_args     = --daemon</div><div class="line">    log_on_failure  += USERID</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　可以看到rysnc服务是关闭的(disable = yes)，这里把它开启，把disable的值改为no</p>
<h3 id="2、-创建rsync服务器配置文件-etc-rsyncd-conf"><a href="#2、-创建rsync服务器配置文件-etc-rsyncd-conf" class="headerlink" title="2、  创建rsync服务器配置文件/etc/rsyncd.conf"></a>2、  创建rsync服务器配置文件/etc/rsyncd.conf</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">vim /etc/rsyncd.conf</div><div class="line"></div><div class="line">uid = root</div><div class="line">gid = root</div><div class="line">port = 873                                      <span class="comment">#　指定运行端口，默认是873，您可以自己指定</span></div><div class="line">hosts allow = 192.168.0.204, 192.168.1.205      <span class="comment"># 允许访问的客户机</span></div><div class="line"><span class="comment">#hosts deny = 0.0.0.0/32                        #　拒绝访问的</span></div><div class="line">use chroot = </div><div class="line">max connections = </div><div class="line">timeout=</div><div class="line"></div><div class="line"><span class="comment"># 下面这些文件是安装完RSYNC服务后自动生成的文件,当然也可以手动配置到指定路径</span></div><div class="line"></div><div class="line">pid file = /var/run/rsyncd.pid      <span class="comment">#pid文件的存放</span></div><div class="line">lock file = /var/run/rsync.lock     <span class="comment">#锁文件的存放位置</span></div><div class="line"><span class="built_in">log</span> file = /var/<span class="built_in">log</span>/rsyncd.log      <span class="comment">#日志记录文件的存放</span></div><div class="line">motd file = /etc/rsyncd.motd        <span class="comment">#欢迎</span></div><div class="line"></div><div class="line"><span class="comment"># 上面这段是全局配置，下面的模块可以有</span></div><div class="line"></div><div class="line">[<span class="built_in">test</span>]                                        <span class="comment"># 模块名字，自己命名</span></div><div class="line">path = /home/hyj/workspace/<span class="built_in">test</span>               <span class="comment"># 指定文件目录所在位置，这是必须指定 </span></div><div class="line">comment = rsync files                         <span class="comment"># 注释</span></div><div class="line">ignore errors                                 <span class="comment"># 忽略IO</span></div><div class="line"><span class="built_in">read</span> only = yes </div><div class="line">list = no                                     <span class="comment"># 是否把rsync 服务器上提供同步数据的目录显示</span></div><div class="line">auth users = rsync                            <span class="comment"># 同步验证时用的账号，如果没有这项就是匿名同步，client同步时不用用户名也能同步。</span></div><div class="line">secrets file = /etc/rsync.passwd              <span class="comment"># 指定认证文件</span></div></pre></td></tr></table></figure>
<h3 id="3、-创建认证文件："><a href="#3、-创建认证文件：" class="headerlink" title="3、  创建认证文件："></a>3、  创建认证文件：</h3><h4 id="3-1-创建认证文件"><a href="#3-1-创建认证文件" class="headerlink" title="3.1. 创建认证文件"></a>3.1. 创建认证文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/rsync.passwd</div><div class="line"></div><div class="line">rsync:hyl            <span class="comment"># 用户名：密码。注意这个不是系统用户，只是rsync用户。所以不用useradd。</span></div></pre></td></tr></table></figure>
<p>　　名字随便写，只要和上边配置文件里的“auth users”参数一致即可，格式(一行一个用户)账号：密码</p>
<h4 id="3-2-修改认证文件权限"><a href="#3-2-修改认证文件权限" class="headerlink" title="3.2. 修改认证文件权限"></a>3.2. 修改认证文件权限</h4><p>　　把认证文件的权限改成600</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 600 /etc/rsync.passwd          <span class="comment">## 只能所有者可读，否则报错</span></div></pre></td></tr></table></figure>
<h3 id="4、-欢迎信息"><a href="#4、-欢迎信息" class="headerlink" title="4、 欢迎信息"></a>4、 欢迎信息</h3><p>　　如果在配置文件中指定了欢迎信息，在/etc下创建rsyncd.motd，设置欢迎信息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/rsyncd.motd</div><div class="line"></div><div class="line">      Welcome the rsync services!</div></pre></td></tr></table></figure>
<h1 id="三-启动rsync"><a href="#三-启动rsync" class="headerlink" title="三. 启动rsync"></a>三. 启动rsync</h1><h3 id="1、-在server端将rsync启动："><a href="#1、-在server端将rsync启动：" class="headerlink" title="1、 在server端将rsync启动："></a>1、 在server端将rsync启动：</h3><h4 id="1-1-启动rsync服务端（以守护进程形式，独立启动）"><a href="#1-1-启动rsync服务端（以守护进程形式，独立启动）" class="headerlink" title="1.1 启动rsync服务端（以守护进程形式，独立启动）"></a>1.1 启动rsync服务端（以守护进程形式，独立启动）</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/rsync --daemon</div></pre></td></tr></table></figure>
<h4 id="1-2-启动rsync服务端-（以xinetd超级进程启动）"><a href="#1-2-启动rsync服务端-（以xinetd超级进程启动）" class="headerlink" title="1.2 启动rsync服务端 （以xinetd超级进程启动）"></a>1.2 启动rsync服务端 （以xinetd超级进程启动）</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/rc.d/init.d/xinetd reload(reload是网上的说法，但是我试了一下报错，start可以)</div></pre></td></tr></table></figure>
<h3 id="2、-防火墙设置："><a href="#2、-防火墙设置：" class="headerlink" title="2、 防火墙设置："></a>2、 防火墙设置：</h3><p>　　如果服务器上装有防火墙，需在服务器中设置iptables将837端口开放。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iptables -A INPUT -p tcp --dport 873 -j ACCEPT</div></pre></td></tr></table></figure>
<h1 id="四-配置rsync客户端"><a href="#四-配置rsync客户端" class="headerlink" title="四. 配置rsync客户端"></a>四. 配置rsync客户端</h1><h3 id="1、用安装服务器端的方式安装rsync。"><a href="#1、用安装服务器端的方式安装rsync。" class="headerlink" title="1、用安装服务器端的方式安装rsync。"></a>1、用安装服务器端的方式安装rsync。</h3><p>　　启动rsync，如果报如下错误，是因为在etc下没有rsyncd.conf配置文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rsync --daemon</div><div class="line">Failed to parse config file: /etc/rsyncd.conf</div></pre></td></tr></table></figure>
<p>　　创建配置文件 <code>/etc/rsyncd.conf</code> 文件内容为空就行。然后启动rsync，可以启动</p>
<h3 id="2、Rsync的命令格式可以为以下六种："><a href="#2、Rsync的命令格式可以为以下六种：" class="headerlink" title="2、Rsync的命令格式可以为以下六种："></a>2、Rsync的命令格式可以为以下六种：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">　　rsync [OPTION]... SRC DEST</div><div class="line">　　rsync [OPTION]... SRC [USER@]HOST:DEST</div><div class="line">　　rsync [OPTION]... [USER@]HOST:SRC DEST</div><div class="line">　　rsync [OPTION]... [USER@]HOST::SRC DEST</div><div class="line">　　rsync [OPTION]... SRC [USER@]HOST::DEST</div><div class="line">　　rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]</div></pre></td></tr></table></figure>
<p>　　常用为以下两种：</p>
<h4 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rsync [OPTION]... [USER@]HOST::SRC   DEST</div></pre></td></tr></table></figure>
<p>　　从远程rsync服务器中拷贝文件到本地机。当SRC路径信息包含”::”分隔符时启动该模式。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如：rsync -av root@172.16.78.192::www /databack</div></pre></td></tr></table></figure>
<h4 id="第二种："><a href="#第二种：" class="headerlink" title="第二种："></a>第二种：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rsync [OPTION]... SRC   [USER@]HOST::DEST</div></pre></td></tr></table></figure>
<p>　　从本地机器拷贝文件到远程rsync服务器中。当DST路径信息包含”::”分隔符时启动该模式。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如：rsync -av /databack root@172.16.78.192::www</div></pre></td></tr></table></figure>
<h3 id="3、下面为实例："><a href="#3、下面为实例：" class="headerlink" title="3、下面为实例："></a>3、下面为实例：</h3><p>　　服务器ip为192.168.8.126，客户端ip为192.168.8.122</p>
<p>　　(1)、把服务器上的/home/hyj/workspace/test文件夹中的内容备份到客户端的/usr/local/share/rsync_backup中:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/rsync -vzrtopg --delete  --progress rsync@192.168.8.126::<span class="built_in">test</span> /usr/<span class="built_in">local</span>/share/rsync_backup</div></pre></td></tr></table></figure>
<p>　　<code>/etc/rsyncd.conf</code> 中模块的内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">test</span>]</div><div class="line">path = /home/hyj/workspace/<span class="built_in">test</span></div><div class="line">comment = rsync files</div><div class="line">ignore errors</div><div class="line"><span class="built_in">read</span> only = yes</div><div class="line">list = no</div><div class="line">auth users = rsync</div><div class="line">secrets file = /etc/rsync.passwd</div></pre></td></tr></table></figure>
<p>　　上面这个命令行中-vzrtopg里的v是verbose，z是压缩，r是recursive，topg都是保持文件原有属性如属主、时间的参数（也可以用直接用a来代替rtopg， a为 –archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD）。–progress是指显示出详细的进度情况，–delete是指如果服务器端删除了这一文件，那么客户端也相应把文件删除，保持真正的一致。</p>
<p>　　（2）、上面的命令需要在备份的时候需要输入密码，可以在客户端建立一个密码文件，在命令中把密码文件作为参数带入：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/rsync.passwd</div><div class="line"></div><div class="line">hyl</div></pre></td></tr></table></figure>
<p>　　密码文件中不用输入用户名，只需输入密码即可。</p>
<p>　　这份密码文件权限属性要设得只有root可读，不然会报错，修改属性：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 600 /etc/rsync.passwd</div></pre></td></tr></table></figure>
<p>　　用下面这条命令，可以不输入密码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/rsync -vzrtopg --delete  --progress --password-file=/etc/rsync.passwd rsync@192.168.8.126::<span class="built_in">test</span> /usr/<span class="built_in">local</span>/share/rsync_backup</div></pre></td></tr></table></figure>
<p>　　(3)、 带exclude 参数</p>
<p>　　把服务器上的/home/hyj/workspace/test文件夹中的内容备份到客户端的/usr/local/share/rsync_backup中，但不包括:res目录和default.properties文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/rsync -vzrtopg --delete --exclude <span class="string">"res/"</span> --exclude <span class="string">"default.properties"</span> --progress --password-file=/etc/rsync.passwd rsync@192.168.8.126::<span class="built_in">test</span> /usr/<span class="built_in">local</span>/share/rsync_backup</div></pre></td></tr></table></figure>
<p><strong> exclude/include规则实例 </strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Here are some exclude/include examples:</div><div class="line"> --exclude <span class="string">"*.o"</span>   would exclude all filenames matching *.o</div><div class="line"> --exclude <span class="string">"/foo"</span>  would exclude a file <span class="keyword">in</span> the base directory called foo</div><div class="line"> --exclude <span class="string">"foo/"</span>  would exclude any directory called foo.</div><div class="line"> --exclude <span class="string">"/foobar"</span> would exclude any file called bar two or more levels below a base directory called foo.</div><div class="line"> --include <span class="string">"*/"</span> --include <span class="string">"*.c"</span> --exclude <span class="string">"*"</span> would include all directories and C <span class="built_in">source</span> files</div><div class="line">--include <span class="string">"foo/"</span> --include <span class="string">"foo/bar.c"</span> --exclude <span class="string">"*"</span> would include only foo/bar.c</div><div class="line"> (the foo/ directory must be explicitly included or it would be excluded by the <span class="string">"*"</span>)</div></pre></td></tr></table></figure>
<p>　　(4)、 把客户端上的/home/hyj/vitest文件夹中的内容备份到服务器的/usr/local/share/rsync_backup中，在客户端执行如下命令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/rsync -vzrtopg --delete --progress --password-file=/etc/rsync.passwd /home/hyj/vitest rsync@192.168.8.126::clientdata</div></pre></td></tr></table></figure>
<p>　　此时服务器的配置文件/etc/rsyncd.conf内容为:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">uid = root</div><div class="line">gid = root</div><div class="line">hosts allow = 192.168.8.122, 192.168.8.123</div><div class="line"><span class="comment">#hosts deny = 0.0.0.0/32</span></div><div class="line">use chroot = no</div><div class="line">max connections = 10</div><div class="line">pid file = /var/run/rsyncd.pid</div><div class="line">lock file = /var/run/rsync.lock</div><div class="line"><span class="built_in">log</span> file = /var/<span class="built_in">log</span>/rsyncd.log</div><div class="line">timeout=600</div><div class="line"></div><div class="line">[<span class="built_in">test</span>]</div><div class="line">path = /home/hyj/workspace/<span class="built_in">test</span></div><div class="line">comment = rsync files</div><div class="line">ignore errors</div><div class="line"><span class="built_in">read</span> only = yes</div><div class="line">list = no</div><div class="line">auth users = rsync</div><div class="line">secrets file = /etc/rsync.passwd</div><div class="line"></div><div class="line"> <span class="comment"># 上面的命令中，客户端的数据备份到clientdata模块中，备份到/usr/local/share/rsync_backup文件夹下，read only改为no，# # 否则会报 `ERROR: module is read only` 的错误</span></div><div class="line"></div><div class="line">[clientdata]</div><div class="line">path = /usr/<span class="built_in">local</span>/share/rsync_backup</div><div class="line">comment = rsync files</div><div class="line">ignore errors</div><div class="line"><span class="built_in">read</span> only = no</div><div class="line">list = no</div><div class="line">auth users = rsync</div><div class="line">secrets file = /etc/rsync.passwd</div></pre></td></tr></table></figure>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h3 id="1、我需要在防火墙上开放哪些端口以适应rsync？"><a href="#1、我需要在防火墙上开放哪些端口以适应rsync？" class="headerlink" title="1、我需要在防火墙上开放哪些端口以适应rsync？"></a>1、我需要在防火墙上开放哪些端口以适应rsync？</h3><p>　　视情况而定</p>
<p>　　rsync可以直接通过873端口的tcp连接传文件，也可以通过22端口的ssh来进行文件传递，但你也可以通过下列命令改变它的端口：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rsync --port 8730 otherhost::</div><div class="line">或者</div><div class="line">rsync <span class="_">-e</span> <span class="string">'ssh -p 2002'</span> otherhost:</div></pre></td></tr></table></figure>
<h3 id="2、-我如何通过rsync只复制目录结构，忽略掉文件呢？"><a href="#2、-我如何通过rsync只复制目录结构，忽略掉文件呢？" class="headerlink" title="2、 我如何通过rsync只复制目录结构，忽略掉文件呢？"></a>2、 我如何通过rsync只复制目录结构，忽略掉文件呢？</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rsync -av --include <span class="string">'*/'</span> --exclude <span class="string">'*'</span> <span class="built_in">source</span>-dir dest-dir</div></pre></td></tr></table></figure>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rsync: failed to connect to 218.107.243.2: No route to host (113) </div><div class="line">rsync error: error <span class="keyword">in</span> socket IO (code 10) at clientserver.c(104) [receiver=2.6.9]</div></pre></td></tr></table></figure>
<p>　　解决：对方没开机、防火墙阻挡、通过的网络上有防火墙阻挡，都有可能。关闭防火墙，其实就是把tcp udp 的873端口打开：</p>
<hr>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">password file must not be other-accessible </div><div class="line">continuing without password file </div><div class="line">Password:</div></pre></td></tr></table></figure>
<p>　　解决：这是因为rsyncd.pwd rsyncd.sec的权限不对，应该设置为600。如：<code>chmod 600 rsyncd.pwd</code></p>
<hr>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@ERROR: auth failed on module xxxxx </div><div class="line">rsync: connection unexpectedly closed (90 bytes <span class="built_in">read</span> so far) </div><div class="line">rsync error: error <span class="keyword">in</span> rsync protocol data stream (code 12) at io.c(150)</div></pre></td></tr></table></figure>
<p>　　解决：这是因为密码设置错了，无法登入成功，检查一下rsync.pwd，看客服是否匹配。还有服务器端没启动rsync 服务也会出现这种情况。 </p>
<hr>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@ERROR: chroot failed </div><div class="line">rsync: connection unexpectedly closed (75 bytes <span class="built_in">read</span> so far) </div><div class="line">rsync error: error <span class="keyword">in</span> rsync protocol data stream (code 12) at io.c(150)</div></pre></td></tr></table></figure>
<p>　　解决：这是因为你在 rsync.conf 中设置的 path 路径不存在，要新建目录才能开启同步。 </p>
<hr>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@hyj rsync_backup]<span class="comment"># /usr/bin/rsync -vzrtopg --delete --exclude "res/" --exclude "default.properties" --progress rsync@192.168.8.126::test /usr/local/share/rsync_backup --password-file=/etc/rsync.pass</span></div><div class="line"></div><div class="line">@ERROR: <span class="built_in">chdir</span> failed</div><div class="line"></div><div class="line">rsync error: error starting client-server protocol (code 5) at main.c(1516) [Receiver=3.0.9]</div></pre></td></tr></table></figure>
<p>　　原因及解决办法：SELinux；（下面这条命令在服务器端执行）<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setsebool -P rsync_disable_trans on</div></pre></td></tr></table></figure></p>
<hr>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ERROR: module is <span class="built_in">read</span> only</div><div class="line">rsync: <span class="built_in">read</span> error: Software caused connection abort (113)</div><div class="line">rsync error: error <span class="keyword">in</span> rsync protocol data stream (code 12) at io.c(769) [sender=3.0.8]</div></pre></td></tr></table></figure>
<p>　　解决：这是因为服务器端配置文件rsyncd.conf中read only = yes，为只读，即不允许客户端上传文件，改成no就可以了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文详细介绍了rsync安装配置实例。&lt;br&gt;
    
    </summary>
    
      <category term="service" scheme="http://www.unix-like.com/categories/service/"/>
    
    
      <category term="rsync" scheme="http://www.unix-like.com/tags/rsync/"/>
    
  </entry>
  
  <entry>
    <title>pdflush进程详解与优化</title>
    <link href="http://www.unix-like.com/2017/05/25/system/pdflush%E8%BF%9B%E7%A8%8B%E8%AF%A6%E8%A7%A3%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://www.unix-like.com/2017/05/25/system/pdflush进程详解与优化/</id>
    <published>2017-05-25T08:38:28.000Z</published>
    <updated>2017-05-26T05:20:14.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>　　由于页高速缓存的缓存作用，写操作实际上会被延迟。当页高速缓存中的数据比后台存储的数据更新时，那么该数据就被称做脏数据。在内存中累积起来的脏页最终必须被写回磁盘。</p>
<a id="more"></a>
<p>在以下两种情况发生时，脏页被写回磁盘：</p>
<ul>
<li>当空闲内存低于一个特定的阈值时，内核必须将脏页写回磁盘，以便释放内存。</li>
<li>当脏页在内存中驻留时间超过一个特定的阈值时，内核必须将超时的脏页写回磁盘，以确保脏页不会无限期地驻留在内存中。</li>
</ul>
<p>　　上面两种工作的目的完全不同。实际上，在老内核中，这是由两个独立的内核线程分别完成的。但是在2.6内核中，由一群内核线程—pdflush后台回写例程—统一执行两种工作。</p>
<p>　　我们来看看这两个目标是如何具体实现的。首先，当系统中的空闲内存低于一个特定的阈值时，pdflush线程将脏页刷新回磁盘。该后台回写例程的目的在于在可用物理内存过低时，释放脏页以重新获得内存。特定的内存阈值可以通过<code>dirty_background_ratio</code>参数设置。当空闲内存比阈值<code>dirty_ background_ratio</code>还低时，内核便会调用函数<code>wakeup_bdflush()</code>唤醒一个pdflush线程，随后pdflush线程进一步调用函数<code>background_writeout()</code>开始将脏页写回磁盘。函数<code>background_ writeout()</code>需要一个长整型参数，该参数指定试图回写的页面数目。</p>
<p>　　函数<code>background_writeout()</code>会连续地写出数据，直到满足以下两个条件：</p>
<ul>
<li>已经有指定的最小数目的页被写出到磁盘。</li>
<li>空闲内存数已经回升，超过了阈值dirty_background_ratio。</li>
</ul>
<p>　　上述条件确保了pdflush操作可以减轻系统中内存不足的压力。回写操作不会在达到这两个条件前停止，除非pdflush写回了所有的脏页，没有剩下的脏页可再被写回了。</p>
<p>　　要满足第二个目标，pdflush后台例程会被周期性唤醒（和空闲内存是否过低无关），将那些在内存中驻留时间过长的脏页写出，确保内存中不会有长期存在的脏页。假如系统发生崩溃，则内存会处于混乱之中，而那些在内存中还没来得及写回磁盘的脏页就会丢失，所以周期性同步回写非常重要。</p>
<p>　　在系统启动时，内核初始化一个定时器，让它周期地唤醒pdflush线程，随后使其运行函数<code>wb_kupdate()</code>。该函数将把所有驻留时间超过百分之<code>dirty_expire_centisecs</code>秒的脏页写回。然后定时器将再次被初始化为百分之<code>dirty_expire_ centisecs</code>秒后唤醒pdflush线程。</p>
<p>　　总而言之，pdflush线程周期地被唤醒并且把超过特定期限的脏页写回磁盘。</p>
<h1 id="二、proc下的相关控制参数"><a href="#二、proc下的相关控制参数" class="headerlink" title="二、proc下的相关控制参数"></a>二、proc下的相关控制参数</h1><p>　　系统管理员可以在/proc/sys/vm中设置回写相关的参数，也可以通过sysctl系统调用设置它们。</p>
<ul>
<li>/proc/sys/vm/dirty_ratio</li>
</ul>
<p>　　这个参数控制一个进程在文件系统中的文件系统写缓冲区的大小，单位是百分比，表示系统内存的百分比，表示当一个进程中写缓冲使用到系统内存多少的时候，再有磁盘写操作时开始向磁盘写出数据。增大之会使用更多系统内存用于磁盘写缓冲，也可以极大提高系统的写性能。但是，当你需要持续、恒定的写入场合时，应该降低其数值.一般缺省是 40。设置方法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> 30 &gt;/proc/sys/vm/dirty_ratio</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>/proc/sys/vm/dirty_background_ratio</li>
</ul>
<p>　　这个参数控制文件系统的pdflush进程，在何时刷新磁盘。单位是百分比，表示系统总内存的百分比，意思是当磁盘的脏数据缓冲到系统内存多少的时候，pdflush开始把脏数据刷新到磁盘。增大会使用更多系统内存用于磁盘写缓冲，也可以极大提高系统的写性能。但是，当你需要持续、恒定的写入场合时，应该降低其数值.一般缺省是10。设置方法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> 8 &gt;/proc/sys/vm/dirty_background_ratio</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>/proc/sys/vm/dirty_writeback_centisecs</li>
</ul>
<p>　　Pdflush写后台进程每隔多久被唤醒并执行把脏数据写出到硬盘。单位是 1/100 秒。如果你的系统是持续地写入动作，那么实际上还是降低这个数值比较好，这样可以把尖峰的写操作削平成多次写操作。缺省数值是500，也就是 5 秒。设置方法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> 200 &gt;/proc/sys/vm/dirty_writeback_centisecs</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>/proc/sys/vm/dirty_expire_centisecs</li>
</ul>
<p>　　这个参数声明Linux内核写缓冲区里面的脏数据多“旧”了之后，pdflush 进程就开始考虑写到磁盘中去。单位是 1/100秒。对于特别重载的写操作来说，这个值适当缩小也是好的，但也不能缩小太多，因为缩小太多也会导致IO提高太快。缺省是 30000，也就是 30 秒的数据就算旧了，将会刷新磁盘。建议设置为 1500，也就是15秒算旧。设置方法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> 1500 &gt;/proc/sys/vm/dirty_expire_centisecs</div></pre></td></tr></table></figure>
<hr>
<h1 id="三、内核参数修改后的生效"><a href="#三、内核参数修改后的生效" class="headerlink" title="三、内核参数修改后的生效"></a>三、内核参数修改后的生效</h1><p>　　Linux在系统运行时修改内核参数(/proc/sys与/etc/sysctl.conf)，而不需要重新引导系统，这个功能是通过/proc虚拟文件系统实现的。</p>
<p>　　在/proc/sys目录下存放着大多数的内核参数，并且设计成可以在系统运行的同时进行更改,可以通过更改/proc/sys中内核参数对应的文件达到修改内核参数的目的(修改过后，保存配置文件就马上自动生效)，不过重新启动机器后之前修改的参数值会失效，所以只能是一种临时参数变更方案。(适合调试内核参数优化值的时候使用，如果设置值有问题，重启服务器还原原来的设置参数值了。简单方便。)</p>
<p>　　但是如果调试内核参数优化值结束后，需要永久保存参数值，就要通过修改/etc/sysctl.conf内的内核参数来永久保存更改。但只是修改sysctl文件内的参数值，确认保存修改文件后，设定的参数值并不会马上生效，如果想使参数值修改马上生效，并且不重启服务器，可以执行下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl –p</div></pre></td></tr></table></figure>
<hr>
<p>　　下面介绍一下/proc/sys下内核文件与配置文件sysctl.conf中变量的对应关系：</p>
<p>　　由于可以修改的内核参数都在/proc/sys目录下，所以sysctl.conf的变量名省略了目录的前面部分（/proc/sys）。即将/proc/sys中的文件转换成sysctl中的变量依据下面两个简单的规则：</p>
<ol>
<li>去掉前面部分/proc/sys</li>
<li>将文件名中的斜杠变为点</li>
</ol>
<p>　　这两条规则可以将/proc/sys中的任一文件名转换成sysctl中的变量名。</p>
<p>　　例如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/proc/sys/net/ipv4/ip_forward =&gt; net.ipv4.ip_forward</div><div class="line">/proc/sys/kernel/hostname =&gt;  kernel.hostname</div></pre></td></tr></table></figure>
<p>　　可以使用下面命令查询所有可修改的变量名</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl –a</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;p&gt;　　由于页高速缓存的缓存作用，写操作实际上会被延迟。当页高速缓存中的数据比后台存储的数据更新时，那么该数据就被称做脏数据。在内存中累积起来的脏页最终必须被写回磁盘。&lt;/p&gt;
    
    </summary>
    
      <category term="system" scheme="http://www.unix-like.com/categories/system/"/>
    
    
      <category term="调优" scheme="http://www.unix-like.com/tags/%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB归档及压缩工具</title>
    <link href="http://www.unix-like.com/2017/05/25/database/MongoDB%E5%BD%92%E6%A1%A3%E5%8F%8A%E5%8E%8B%E7%BC%A9%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.unix-like.com/2017/05/25/database/MongoDB归档及压缩工具/</id>
    <published>2017-05-25T08:02:28.000Z</published>
    <updated>2017-05-26T02:31:19.001Z</updated>
    
    <content type="html"><![CDATA[<p>　　原文地址：<a href="http://t.dbdao.com/archives/archiving-and-compression-in-mongodb-tools.html" target="_blank" rel="external">http://t.dbdao.com/archives/archiving-and-compression-in-mongodb-tools.html</a></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>　　我在MongoDB World 2015做的演讲“Putting the Go in MongoDB”，重点是关于MongoDB工具的重写，从C ++到Go，这在可用性以及性能方面得到了一些改进，但是这里我只简要的说两个方面的新功能，(planned for the 3.2 release) – 归档和压缩。</p>
<p>　　在本文中，我将对mongodump和mongorestore提供更详细的归档和压缩特性说明，并探索使用这些特性的可行用例。</p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>　　一个通常目的的归档一般由一个或多个文件组成。这样例子如磁带归档格式(tar)，其中包含按顺序组成的一个或多个文件。归档在执行进程间通信的应用程序中尤其有用，例如，你可以通过远程服务器进行目录的tarball压缩，然后通过SSH，传送到到本机上进行解压：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh source.server.com tar c sourceDirectory | tar x</div></pre></td></tr></table></figure>
<p>　　由于归档以顺序的方式创建，接收端将能按顺序接收到发送端按顺序发来的数据。</p>
<p>　　在3.0中，我们增加了在MongoDB中并发执行备份和恢复多个集合的能力，这可以让你执行备份时，更加充分地利用磁盘I / O。 结果，写入mongodump的备份并不一定以顺序的方式接收。 同样，mongorestore同时读取还原操作集合，它的读取指令也并非是序列性的。</p>
<p>　　通用归档格式，如tar，只支持连续的文件归档打包。mongodump和mongorestore利用这些备份格式，将得到一个不可接受的性能退化， 由于所有集合的数据将不得不被按顺序写入和读出。为了支持这些工具的并发行为，我们研发了一个特殊的通用备份格式，支持非并发文件的写入。 这个新的归档特性极大了提高了备份和还原操作的效率。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>　　为了按上下文情况进行备份，我们考虑一下你们通常是如何创建备份的。比如，假设你有一个“country”的数据库，其中含有两个集合： “nigeria” and “austria”， 你可能会这样操作：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongodump --db country</div></pre></td></tr></table></figure>
<p>　　上面的指令读取“country”数据库的所有集合， 然后将其写入“dump”目录。 上面的指令就会产生以下的目录列表：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dump/</div><div class="line">└── [4.3M]  country</div><div class="line">    ├── [2.1M]  austria.bson</div><div class="line">    ├── [  87]  austria.metadata.json</div><div class="line">    ├── [2.1M]  nigeria.bson</div><div class="line">    ├── [  87]  nigeria.metadata.json</div><div class="line">    └── [ 140]  system.indexes.bson</div><div class="line"> </div><div class="line">1 directory, 5 files</div></pre></td></tr></table></figure>
<p>　　你也可以备份整个服务器-这里的服务器包含两个数据库(country 和product)。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongodump</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">├── [5.4M]  dump</div><div class="line">│   ├── [4.03M]  country</div><div class="line">│   │   ├── [2.1M]  austria.bson</div><div class="line">│   │   ├── [  87]  austria.metadata.json</div><div class="line">│   │   ├── [2.1M]  nigeria.bson</div><div class="line">│   │   ├── [  87]  nigeria.metadata.json</div><div class="line">│   │   └── [ 140]  system.indexes.bson</div><div class="line">│   └── [1.1M]  product</div><div class="line">│       ├── [1.0M]  mongodump.bson</div><div class="line">│       ├── [  89]  mongodump.metadata.json</div><div class="line">│       └── [  72]  system.indexes.bson</div><div class="line">2 directories, 8 files</div></pre></td></tr></table></figure>
<p>　　或选择备份单个集合到标准输出，而不是一个目录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongodump --db country --collection nigeria --out -</div></pre></td></tr></table></figure>
<h1 id="归档支持"><a href="#归档支持" class="headerlink" title="归档支持"></a>归档支持</h1><p>　　在3.2中，我们引入了创建备份的一个附加模式 －－ “归档”模式，写入所有转储数据，甚至从不同的数据库和集合到单一的输出文件。 使用mongodump创建归档是极为简单的 – 只需要一个附加选项：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mongodump --db country --archive=country.archive</div><div class="line">	</div><div class="line">-rw-rw-r-- 1 wisdom wisdom 4.2M Jun 29 11:12 country.archive</div></pre></td></tr></table></figure>
<p>　　上面的指令将在“country.archive”文件中创建“country”的数据库归档。默认情况下，归档被写入到标准输出。不同于目录模式的执行备份，创建目录树，默认归档模式下备份结果就是一个单一的文件， 包含“country”数据库的所有数据-所有集合，索引等。</p>
<p>　　你也可以备份一个单一的集合或整个服务器的内容：</p>
<p>　　<strong>单一集合：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mongodump --db country --collection nigeria --archive=nga.archive</div><div class="line">	</div><div class="line">-rw-rw-r-- 1 wisdom wisdom 2.1M Jun 29 11:15 nga.archive</div></pre></td></tr></table></figure>
<p>　　<strong>整个服务器：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mongodump --archive=server.archive</div><div class="line">	</div><div class="line">-rw-rw-r-- 1 wisdom wisdom 5.3M Jun 29 11:26 server.archive</div></pre></td></tr></table></figure>
<p>　　在mongodump的这种情况下，归档模式允许多个集合以非连续的方式打包在归档文件内。在mongorestore中，它允许多个集合进行并行恢复。这样，你可以在网络上执行数据迁移，降低磁盘I/O所占空间，享受到充分利用工具和底层存储引擎的并发所带来的好处。</p>
<h1 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h1><p>　　一个新的备份改善的例子， 是mongodump和mongorestore之间的进程间通信 – 特别是能够将数据从一个传到另一个。在以前的版本中，这种支持有限 – 一个时间只能传输一个集合。现在，使用归档就没有这样的限制。这种方式对于数据库服务器出于安全考虑而安装有防火墙的情况下很有用。在这种情况下，一个通常的设计是允许一个或多个服务器方访问数据库。使用归档功能，在SSH上进行数据转移数据，就轻而易举了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh wisdom@proxy.server.com mongodump --host source.server.com --archive  | ssh wisdom@target.server.com mongorestore --archive</div></pre></td></tr></table></figure>
<p>　　上面的指令使用SSH方式连接到代理主机（proxy.server.com），访问源服务器（source.server.com），在代理服务器上运行mongodump，为了最终的恢复，将源服务器的发送内容（通过SSH）到目标服务器（target.server.com）。</p>
<p>　　如果没有归档，通过mongodump完成这些操作的唯一办法就是，先执行备份到磁盘，在将文件复制到目标服务器，然后运行mongorestore。通过备份，一个指令就可以完成- 无需任何附加磁盘I/O的开销。</p>
<h1 id="压缩支持"><a href="#压缩支持" class="headerlink" title="压缩支持"></a>压缩支持</h1><p>　　除了备份，我们还使用gzip进行压缩。这是通过在mongodump和mongorestore中引入一个新的指令行选项 “–gzip” 实现的。 压缩可用于目录以及归档模型下创建的备份，压缩还可以减少磁盘空间使用。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongodump --db country --gzip</div></pre></td></tr></table></figure>
<p>　　生成：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dump/</div><div class="line">└── [568K]  country</div><div class="line">    ├── [254K]  austria.bson.gz</div><div class="line">    ├── [ 100]  austria.metadata.json.gz</div><div class="line">    ├── [254K]  nigeria.bson.gz</div><div class="line">    ├── [ 100]  nigeria.metadata.json.gz</div><div class="line">    └── [  91]  system.indexes.bson.gz</div><div class="line"> </div><div class="line">1 directory, 5 files</div></pre></td></tr></table></figure>
<p>　　注意,目录模型的归档备份大小-568KB-比没有压缩的备份要小很多-4.3MB.</p>
<p>　　<strong>压缩归档：</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mongodump --db country --gzip --archive=country.archive</div><div class="line"></div><div class="line">-rw-rw-r-- 1 wisdom wisdom 509K Jun 29 11:23 country.archive</div></pre></td></tr></table></figure>
<p>　　对于归档来说，数据在写入归档之前需要先压缩。</p>
<p>　　恢复压缩目录模式备份，你应该运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongorestore --gzip</div></pre></td></tr></table></figure>
<p>　　类似用来恢复归档模式下的压缩备份的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh wisdom@proxy.server.com mongodump --host source.server.com --archive --gzip  | ssh wisdom@target.server.com mongorestore --archive --gzip</div></pre></td></tr></table></figure>
<p>　　数据迁移不会产生任何磁盘I / O开销，由于压缩，将会使用更少的网络带宽。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　归档和压缩特性产生了许多用于进行备份和恢复操作的例子。如果你们正在使用MongoDB工具和其它类型的应用程序，我们也乐于倾听你们的经验及用例。 尽管目前最新版本工具还不文档，不过希望大家先对这些特性体验起来。</p>
<p>　　<strong>注：</strong> 作为提供共享集群的集群范围快照的唯一备份解决方案，MongoDB Ops Manager和MongoDB Cloud Mannager被推荐用于较大的MongoDB部署。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　原文地址：&lt;a href=&quot;http://t.dbdao.com/archives/archiving-and-compression-in-mongodb-tools.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://t.dbdao.com/archives/archiving-and-compression-in-mongodb-tools.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;　　我在MongoDB World 2015做的演讲“Putting the Go in MongoDB”，重点是关于MongoDB工具的重写，从C ++到Go，这在可用性以及性能方面得到了一些改进，但是这里我只简要的说两个方面的新功能，(planned for the 3.2 release) – 归档和压缩。&lt;/p&gt;
&lt;p&gt;　　在本文中，我将对mongodump和mongorestore提供更详细的归档和压缩特性说明，并探索使用这些特性的可行用例。&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="http://www.unix-like.com/categories/database/"/>
    
    
      <category term="mongodb" scheme="http://www.unix-like.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>Linux下清空或删除大文件内容的5种方法</title>
    <link href="http://www.unix-like.com/2017/05/25/system/Linux%E4%B8%8B%E6%B8%85%E7%A9%BA%E6%88%96%E5%88%A0%E9%99%A4%E5%A4%A7%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%9A%845%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://www.unix-like.com/2017/05/25/system/Linux下清空或删除大文件内容的5种方法/</id>
    <published>2017-05-25T06:02:28.000Z</published>
    <updated>2017-05-26T02:30:58.885Z</updated>
    
    <content type="html"><![CDATA[<p>编译自：<a href="http://www.tecmint.com/empty-delete-file-content-linux/" target="_blank" rel="external">http://www.tecmint.com/empty-delete-file-content-linux/</a> 作者： Aaron Kili</p>
<p>原创：LCTT <a href="https://linux.cn/article-8024-1.html" target="_blank" rel="external">https://linux.cn/article-8024-1.html</a> 译者： FSSlc </p>
<p>在 Linux 终端下处理文件时，有时我们想直接清空文件的内容但又不必使用任何 Linux 命令行编辑器 去打开这些文件。那怎样才能达到这个目的呢？在这篇文章中，我们将介绍几种借助一些实用的命令来清空文件内容的方法。</p>
<p><strong>注意：</strong> 在我们进一步深入了解这些方法之前，请记住: 由于在 Linux 中一切皆文件，你需要时刻注意，确保你将要清空的文件不是重要的用户文件或者系统文件。清空重要的系统文件或者配置文件可能会引发严重的应用失败或者系统错误。</p>
<p>前面已经说道，下面的这些方法都是从命令行中达到清空文件的目的。</p>
<p><strong>提示：</strong> 在下面的示例中，我们将使用名为 access.log 的文件来作为示例样本。<br><a id="more"></a></p>
<h1 id="1-通过重定向到-Null-来清空文件内容"><a href="#1-通过重定向到-Null-来清空文件内容" class="headerlink" title="1. 通过重定向到 Null 来清空文件内容"></a>1. 通过重定向到 Null 来清空文件内容</h1><p>清空或者让一个文件成为空白的最简单方式，是像下面那样，通过 shell 重定向 <code>null</code> （不存在的事物）到该文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; access.log</div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@localhost logs]<span class="comment"># du -sh catalina.out </span></div><div class="line">9.7G	catalina.out</div><div class="line">[root@localhost logs]<span class="comment"># &gt; catalina.out </span></div><div class="line">[root@localhost logs]<span class="comment"># du -sh catalina.out </span></div><div class="line">0	catalina.out</div></pre></td></tr></table></figure>
<p>在 Linux 下使用 Null 重定向来清空大文件</p>
<h1 id="2-使用-true-命令重定向来清空文件"><a href="#2-使用-true-命令重定向来清空文件" class="headerlink" title="2. 使用 true 命令重定向来清空文件"></a>2. 使用 <code>true</code> 命令重定向来清空文件</h1><p>下面我们将使用 : 符号，它是 shell 的一个内置命令，等同于 true 命令，它可被用来作为一个 no-op（即不进行任何操作）。</p>
<p>另一种清空文件的方法是将 : 或者 true 内置命令的输出重定向到文件中，具体如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">: &gt; access.log</div></pre></td></tr></table></figure>
<p> 或<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="literal">true</span> &gt; access.log</div></pre></td></tr></table></figure></p>
<p>使用 Linux 命令清空大文件</p>
<h1 id="3-使用-cat-cp-dd-实用工具及-dev-null-设备来清空文件"><a href="#3-使用-cat-cp-dd-实用工具及-dev-null-设备来清空文件" class="headerlink" title="3. 使用 cat/cp/dd 实用工具及 /dev/null 设备来清空文件"></a>3. 使用 cat/cp/dd 实用工具及 /dev/null 设备来清空文件</h1><p>在 Linux 中， null 设备基本上被用来丢弃某个进程不再需要的输出流，或者作为某个输入流的空白文件，这些通常可以利用重定向机制来达到。</p>
<p>所以 /dev/null 设备文件是一个特殊的文件，它将清空送到它这里来的所有输入，而它的输出则可被视为一个空文件。</p>
<p>另外，你可以通过使用 cat 命令 显示 /dev/null 的内容然后重定向输出到某个文件，以此来达到清空该文件的目的。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /dev/null &gt; access.log</div></pre></td></tr></table></figure>
<p>使用 cat 命令来清空文件</p>
<p>下面，我们将使用 cp 命令 复制 /dev/null 的内容到某个文件来达到清空该文件的目的，具体如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp /dev/null access.log</div></pre></td></tr></table></figure>
<p>使用 cp 命令来清空文件</p>
<p>而下面的命令中， if 代表输入文件，of 代表输出文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd <span class="keyword">if</span>=/dev/null of=access.log</div></pre></td></tr></table></figure>
<p>使用 dd 命令来清空文件内容</p>
<h1 id="4-使用-echo-命令清空文件"><a href="#4-使用-echo-命令清空文件" class="headerlink" title="4. 使用 echo 命令清空文件"></a>4. 使用 echo 命令清空文件</h1><p>在这里，你可以使用 echo 命令 将空字符串的内容重定向到文件中，具体如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">""</span> &gt; access.log</div></pre></td></tr></table></figure>
<p>或者<br> <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> &gt; access.log</div></pre></td></tr></table></figure></p>
<p>使用 echo 命令来清空文件</p>
<p><strong>注意：</strong>你应该记住空字符串并不等同于 null 。字符串表明它是一个具体的事物，只不过它的内容可能是空的，但 null 则意味着某个事物并不存在。</p>
<p>基于这个原因，当你将 echo 命令 的输出作为输入重定向到文件后，使用 cat 命令 来查看该文件的内容时，你将看到一个空白行（即一个空字符串）。</p>
<p>要将 null 做为输出输入到文件中，你应该使用 -n 选项，这个选项将告诉 echo 不再像上面的那个命令那样输出结尾的那个新行。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> -n <span class="string">""</span> &gt; access.log</div></pre></td></tr></table></figure>
<p>使用 Null 重定向来清空文件</p>
<h1 id="5-使用-truncate-命令来清空文件内容"><a href="#5-使用-truncate-命令来清空文件内容" class="headerlink" title="5. 使用 truncate 命令来清空文件内容"></a>5. 使用 truncate 命令来清空文件内容</h1><p>truncate 可被用来将一个文件缩小或者扩展到某个给定的大小。</p>
<p>你可以利用它和 -s 参数来特别指定文件的大小。要清空文件的内容，则在下面的命令中将文件的大小设定为 0:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">truncate <span class="_">-s</span> 0 access.log</div></pre></td></tr></table></figure>
<p>在 Linux 中截断文件内容</p>
<p>我要介绍的就是这么多了。在本文中，我们介绍了几种通过使用一些简单的命令行工具和 shell 重定向机制来清除或清空文件内容的方法。</p>
<p>上面介绍的这些可能并不是达到清空文件内容这个目的的所有可行的实践方法，所以你也可以通过下面的评论栏告诉我们本文中尚未提及的其他方法。</p>
<hr>
<p>via: <a href="http://www.tecmint.com/empty-delete-file-content-linux/" target="_blank" rel="external">http://www.tecmint.com/empty-delete-file-content-linux/</a></p>
<p>作者：Aaron Kili 译者：FSSlc 校对：jasminepeng</p>
<p>本文由 LCTT 原创编译，Linux中国 荣誉推出</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编译自：&lt;a href=&quot;http://www.tecmint.com/empty-delete-file-content-linux/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.tecmint.com/empty-delete-file-content-linux/&lt;/a&gt; 作者： Aaron Kili&lt;/p&gt;
&lt;p&gt;原创：LCTT &lt;a href=&quot;https://linux.cn/article-8024-1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://linux.cn/article-8024-1.html&lt;/a&gt; 译者： FSSlc &lt;/p&gt;
&lt;p&gt;在 Linux 终端下处理文件时，有时我们想直接清空文件的内容但又不必使用任何 Linux 命令行编辑器 去打开这些文件。那怎样才能达到这个目的呢？在这篇文章中，我们将介绍几种借助一些实用的命令来清空文件内容的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在我们进一步深入了解这些方法之前，请记住: 由于在 Linux 中一切皆文件，你需要时刻注意，确保你将要清空的文件不是重要的用户文件或者系统文件。清空重要的系统文件或者配置文件可能会引发严重的应用失败或者系统错误。&lt;/p&gt;
&lt;p&gt;前面已经说道，下面的这些方法都是从命令行中达到清空文件的目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt; 在下面的示例中，我们将使用名为 access.log 的文件来作为示例样本。&lt;br&gt;
    
    </summary>
    
      <category term="system" scheme="http://www.unix-like.com/categories/system/"/>
    
    
      <category term="bash" scheme="http://www.unix-like.com/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>redis模糊删除key</title>
    <link href="http://www.unix-like.com/2017/05/25/database/redis%E6%A8%A1%E7%B3%8A%E5%88%A0%E9%99%A4key/"/>
    <id>http://www.unix-like.com/2017/05/25/database/redis模糊删除key/</id>
    <published>2017-05-25T05:58:41.000Z</published>
    <updated>2017-05-26T02:28:54.700Z</updated>
    
    <content type="html"><![CDATA[<p>Redis keys命令支持模式匹配，但是del命令不支持模式匹配，有时候需要根据一定的模式来模糊删除key，这时只能结合shell命令来完成了。 具体命令是：</p>
<a id="more"></a>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-cli KEYS <span class="string">"pattern"</span> | xargs redis-cli DEL</div></pre></td></tr></table></figure>
<p>其中pattern是keys命令支持的模式，这样就可以模糊删除key了。服务器上测试删除150万条数据的效率也是很高的。</p>
<p>所有的Redis命令可以在这里找到：<a href="http://redis.io/commands" target="_blank" rel="external">http://redis.io/commands</a></p>
<p>KEYS命令：<a href="http://redis.io/commands/keys" target="_blank" rel="external">http://redis.io/commands/keys</a></p>
<p>DEL命令: <a href="http://redis.io/commands/del" target="_blank" rel="external">http://redis.io/commands/del</a></p>
<p><strong>my demo:</strong></p>
<p>prefix_: 需要删除key的匹配的前缀名<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-cli KEYS <span class="string">"prefix_"</span> | xargs redis-cli DEL</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis keys命令支持模式匹配，但是del命令不支持模式匹配，有时候需要根据一定的模式来模糊删除key，这时只能结合shell命令来完成了。 具体命令是：&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="http://www.unix-like.com/categories/database/"/>
    
    
      <category term="redis" scheme="http://www.unix-like.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Linux查看文件编码格式及文件编码转换</title>
    <link href="http://www.unix-like.com/2017/05/25/system/Linux%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8F%8A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/"/>
    <id>http://www.unix-like.com/2017/05/25/system/Linux查看文件编码格式及文件编码转换/</id>
    <published>2017-05-25T04:27:28.000Z</published>
    <updated>2017-05-26T02:29:57.666Z</updated>
    
    <content type="html"><![CDATA[<p>如果你需要在Linux 中操作windows下的文件，那么你可能会经常遇到文件编码转换的问题。Windows中默认的文件格式是GBK(gb2312)，而Linux一般都是UTF-8。下面介绍一下，在Linux中如何查看文件的编码及如何进行对文件进行编码转换。</p>
<a id="more"></a>
<h1 id="查看文件编码"><a href="#查看文件编码" class="headerlink" title="查看文件编码"></a>查看文件编码</h1><p>在Linux中查看文件编码可以通过以下几种方式：</p>
<h3 id="1-在Vim-中可以直接查看文件编码"><a href="#1-在Vim-中可以直接查看文件编码" class="headerlink" title="1.在Vim 中可以直接查看文件编码"></a>1.在Vim 中可以直接查看文件编码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:<span class="built_in">set</span> fileencoding</div></pre></td></tr></table></figure>
<p>即可显示文件编码格式。</p>
<p>如果你只是想查看其它编码格式的文件或者想解决用Vim查看文件乱码的问题，那么你可以在 <code>~/.vimrc</code> 文件中添加以下内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> encoding=utf-8 fileencodings=ucs-bom,utf-8,cp936</div></pre></td></tr></table></figure>
<p>这样，就可以让vim自动识别文件编码（可以自动识别UTF-8或者GBK编码的文件），其实就是依照 fileencodings提供的编码列表尝试，如果没有找到合适的编码，就用latin-1(ASCII)编码打开。</p>
<h3 id="2-enca-如果你的系统中没有安装这个命令，可以用sudo-yum-install-y-enca-安装-查看文件编码"><a href="#2-enca-如果你的系统中没有安装这个命令，可以用sudo-yum-install-y-enca-安装-查看文件编码" class="headerlink" title="2. enca (如果你的系统中没有安装这个命令，可以用sudo yum install -y enca 安装 )查看文件编码"></a>2. enca (如果你的系统中没有安装这个命令，可以用sudo yum install -y enca 安装 )查看文件编码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ enca filename</div><div class="line">filename: Universal transformation format 8 bits; UTF-8</div><div class="line">CRLF line terminators</div></pre></td></tr></table></figure>
<p>需要说明一点的是，enca对某些GBK编码的文件识别的不是很好，识别时会出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unrecognized encoding</div></pre></td></tr></table></figure>
<h1 id="文件编码转换"><a href="#文件编码转换" class="headerlink" title="文件编码转换"></a>文件编码转换</h1><h3 id="1-在Vim中直接进行转换文件编码-比如将一个文件转换成utf-8格式"><a href="#1-在Vim中直接进行转换文件编码-比如将一个文件转换成utf-8格式" class="headerlink" title="1.在Vim中直接进行转换文件编码,比如将一个文件转换成utf-8格式"></a>1.在Vim中直接进行转换文件编码,比如将一个文件转换成utf-8格式</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:<span class="built_in">set</span> fileencoding=utf-8</div></pre></td></tr></table></figure>
<h3 id="2-enconv-转换文件编码，比如要将一个GBK编码的文件转换成UTF-8编码，操作如下"><a href="#2-enconv-转换文件编码，比如要将一个GBK编码的文件转换成UTF-8编码，操作如下" class="headerlink" title="2. enconv 转换文件编码，比如要将一个GBK编码的文件转换成UTF-8编码，操作如下"></a>2. enconv 转换文件编码，比如要将一个GBK编码的文件转换成UTF-8编码，操作如下</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enconv -L zh_CN -x UTF-8 filename</div></pre></td></tr></table></figure>
<h3 id="3-iconv-转换，iconv的命令格式如下："><a href="#3-iconv-转换，iconv的命令格式如下：" class="headerlink" title="3. iconv 转换，iconv的命令格式如下："></a>3. iconv 转换，iconv的命令格式如下：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iconv <span class="_">-f</span> encoding -t encoding inputfile</div></pre></td></tr></table></figure>
<p>比如将一个UTF-8 编码的文件转换成GBK编码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iconv <span class="_">-f</span> GBK -t UTF-8 file1 -o file2</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你需要在Linux 中操作windows下的文件，那么你可能会经常遇到文件编码转换的问题。Windows中默认的文件格式是GBK(gb2312)，而Linux一般都是UTF-8。下面介绍一下，在Linux中如何查看文件的编码及如何进行对文件进行编码转换。&lt;/p&gt;
    
    </summary>
    
      <category term="system" scheme="http://www.unix-like.com/categories/system/"/>
    
    
      <category term="字符集" scheme="http://www.unix-like.com/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Bash历史中执行过的每一项命令设置时间和日期.md</title>
    <link href="http://www.unix-like.com/2017/05/25/system/Bash%E5%8E%86%E5%8F%B2%E4%B8%AD%E6%89%A7%E8%A1%8C%E8%BF%87%E7%9A%84%E6%AF%8F%E4%B8%80%E9%A1%B9%E5%91%BD%E4%BB%A4%E8%AE%BE%E7%BD%AE%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F/"/>
    <id>http://www.unix-like.com/2017/05/25/system/Bash历史中执行过的每一项命令设置时间和日期/</id>
    <published>2017-05-25T04:21:42.000Z</published>
    <updated>2017-05-26T02:29:21.261Z</updated>
    
    <content type="html"><![CDATA[<p>在默认情况下，所有通过 Bash 在命令行中执行过的命令都被存储在历史缓存区或者一个叫做 <code>~/.bash_history</code> 的文件里。这意味着系统管理员可以看到系统上用户执行过的命令清单，或者用户可以通过像 <code>history</code> 命令这样的选项来看他或她自己的命令历史。<br><a id="more"></a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@l-webdb-docker-dev ~]<span class="comment"># history </span></div><div class="line">    1  vim /gotwo_data/scripts/cronjob/sync_mysql_online.sh</div><div class="line">    2  <span class="built_in">exit</span></div><div class="line">    3  ps -ef | grep 4004</div><div class="line">    4  <span class="built_in">exit</span></div><div class="line">    5  mysql</div><div class="line">    6  mysqldump -uroot -p db_ad &gt; /tmp/db_ad.sql</div><div class="line">    7  vim /tmp/db_ad.sql </div><div class="line">    8  mysqldump -uroot -p db_ad &gt; /tmp/db_ad.sql</div></pre></td></tr></table></figure>
<p>从上面<code>history</code>命令的输出可知，命令被执行的日期和时间并没有显示出来。基本上所有的 Linux 发行版的默认设置都是这样的。</p>
<p>在这篇文章里，我们将解释当在 Bash 中执行<code>history</code>命令显示每个命令时，如何配置显示时间戳信息。</p>
<p>每个命令相关的日期和时间可以记录到历史文件中，用 <code>HISTTIMEFORMAT</code> 环境变量的设置作为命令历史的备注记录。</p>
<p>这里有两种可行的方式来达到目的：一种是暂时的效果，一种是永久的效果。</p>
<p>要临时设置 <code>HISTTIMEFORMAT</code>环境变量，在命令行这样输出它：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">export</span> HISTTIMEFORMAT=<span class="string">'%F %T '</span></div></pre></td></tr></table></figure></p>
<p>在上面的输出命令当中，时间戳格式如下：</p>
<ol>
<li><p><code>％F</code>－展开为完整日期，即<code>％Y-％m-％d</code>（年-月-日）。</p>
</li>
<li><p><code>％T</code>－展开为时间，即<code>％H:％M:％S</code>（时:分:秒）。</p>
</li>
</ol>
<p>通读 date 命令的 man 手册来获得更多使用说明：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">man date</div></pre></td></tr></table></figure>
<p>（LCTT 译注：注意：这个功能只能用在当 HISTTIMEFORMAT 这个环境变量被设置之后，之后的那些新执行的 bash 命令才会被打上正确的时间戳。在此之前的所有命令，都将会显示成设置 HISTTIMEFORMAT 变量的时间。）</p>
<p>然而，如果你想永久地配置该变量，用你最喜欢的编辑器打开文件 <code>~/.bashrc</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi ~/.bashrc</div></pre></td></tr></table></figure>
<p>然后在下方添加（用注释将其标记为你自己的配置）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 我的配置</span></div><div class="line"><span class="built_in">export</span> HISTTIMEFORMAT=<span class="string">'%F %T '</span></div></pre></td></tr></table></figure>
<p>保存文件并退出，然后，运行下面的命令以便改动当即生效：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> ~/.bashrc</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在默认情况下，所有通过 Bash 在命令行中执行过的命令都被存储在历史缓存区或者一个叫做 &lt;code&gt;~/.bash_history&lt;/code&gt; 的文件里。这意味着系统管理员可以看到系统上用户执行过的命令清单，或者用户可以通过像 &lt;code&gt;history&lt;/code&gt; 命令这样的选项来看他或她自己的命令历史。&lt;br&gt;
    
    </summary>
    
      <category term="system" scheme="http://www.unix-like.com/categories/system/"/>
    
    
      <category term="bash" scheme="http://www.unix-like.com/tags/bash/"/>
    
  </entry>
  
</feed>
